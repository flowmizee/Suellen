<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Suellen Rocha - Chat</title>
    <script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "sewx606gm7");
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* [Seu CSS completo permanece exatamente igual] */
        /* ... Todo o CSS anterior permanece inalterado ... */
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <img src="perfil.webp" alt="Suellen Rocha" class="profile-pic">
            <div class="header-info">
                <h2>Suellen Rocha</h2>
                <p id="status-text">online</p>
            </div>
        </div>

        <div class="chat-messages" id="chat-messages">
        </div>

        <div class="pix-upload-area" id="pix-upload-area">
            <div class="pix-preview-container">
                <img id="receipt-preview" src="" alt="Pré-visualização do Comprovante" style="display: none;">
            </div>
            <p id="ocr-status-message" class="status-message"></p>
            <input type="file" id="receipt-file-input" accept="image/*">
            <button id="upload-photo-button" class="upload-type-button">
                Enviar Comprovante (Foto)
            </button>
        </div>

        <div class="chat-input-area" id="chat-input-area">
            <input type="text" id="chat-input" class="chat-input" placeholder="Digite sua mensagem...">
            <div class="attachment-buttons">
                <button class="attachment-button" id="attach-button">
                    <img src="anexar.webp" alt="Anexar">
                </button>
                <button class="attachment-button" id="send-photo-button">
                    <img src="enviarfoto.webp" alt="Enviar Foto">
                </button>
            </div>
            <button id="send-button" class="send-button">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send-horizontal"><path d="m3 3 3 9-3 9 19-9Z"/><path d="M6 12h16"/></svg>
            </button>
        </div>
    </div>

    <script src='https://unpkg.com/tesseract.js@5.0.0/dist/tesseract.min.js'></script>
    <script>
        const chatContainer = document.querySelector('.chat-container');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');
        const statusText = document.getElementById('status-text');
        const chatInputArea = document.getElementById('chat-input-area');
        const chatHeader = document.querySelector('.chat-header');

        const pixUploadArea = document.getElementById('pix-upload-area');
        const receiptFileInput = document.getElementById('receipt-file-input');
        const receiptPreview = document.getElementById('receipt-preview');
        const uploadPhotoButton = document.getElementById('upload-photo-button');
        const ocrStatusMessage = document.getElementById('ocr-status-message');
        const attachButton = document.getElementById('attach-button');
        const sendPhotoButton = document.getElementById('send-photo-button');

        let chatHistory = [];
        const API_KEY = "AIzaSyBHUWSEIVXy3z0NT13ps8aU5TOZJWuC9ss";
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;

        let photosSentCount = 0;
        let expectedPaymentAmount = 0;
        let waitingForPaymentReceipt = false;
        let waitingForIntimatePhoto = false;
        let typingIndicatorElement = null;
        let customActionButton = null;
        let tesseractWorker = null;
        let currentPersonaMode = 'caring';
        let lastReceivedIntimatePhoto = false;
        const preloadedImages = [];

        function adjustChatContainerHeight() {
            chatContainer.style.height = `${window.innerHeight}px`;
            adjustChatMessagesPadding();
        }

        function adjustChatMessagesPadding() {
            const headerHeight = chatHeader.offsetHeight;
            const inputAreaHeight = chatInputArea.offsetHeight;

            let currentBottomPadding = inputAreaHeight + 20;

            if (pixUploadArea.style.display === 'flex') {
                currentBottomPadding += pixUploadArea.offsetHeight;
                pixUploadArea.style.bottom = `${inputAreaHeight}px`;
            } else {
                pixUploadArea.style.bottom = `0px`;
            }
            
            chatMessages.style.paddingBottom = `${currentBottomPadding}px`;
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        async function initializeTesseractWorker() {
            if (!tesseractWorker) {
                ocrStatusMessage.textContent = 'Preparando validador de pagamento...';
                try {
                    tesseractWorker = await Tesseract.createWorker('por');
                    ocrStatusMessage.textContent = 'Validador pronto! Envie seu comprovante.';
                } catch (error) {
                    console.error('Erro ao carregar validador:', error);
                    ocrStatusMessage.textContent = 'Erro ao carregar validador. Tente novamente.';
                    throw error;
                }
            }
        }

        async function addMessage(text, sender, isImage = false, imageUrl = '') {
            const messageBubble = document.createElement('div');
            messageBubble.classList.add('message-bubble', sender);

            if (isImage) {
                const img = document.createElement('img');
                img.src = imageUrl;
                img.alt = `Foto de ${sender}`;
                img.onload = () => {
                    adjustChatMessagesPadding();
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                };
                messageBubble.appendChild(img);
            } else {
                messageBubble.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            }

            chatMessages.appendChild(messageBubble);
            adjustChatMessagesPadding();
        }

        async function addTypingIndicatorWithDelay(delayBeforeTyping) {
            await new Promise(resolve => setTimeout(resolve, delayBeforeTyping));
            addTypingIndicator();
        }

        function addTypingIndicator() {
            if (typingIndicatorElement) return;

            typingIndicatorElement = document.createElement('div');
            typingIndicatorElement.classList.add('message-bubble', 'suellen', 'typing-indicator-bubble');
            typingIndicatorElement.innerHTML = `
                <div class="typing-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            `;
            chatMessages.appendChild(typingIndicatorElement);
            adjustChatMessagesPadding();
            chatMessages.scrollTop = chatMessages.scrollHeight;
            statusText.textContent = 'digitando...';
        }

        function removeTypingIndicator() {
            if (typingIndicatorElement) {
                typingIndicatorElement.remove();
                typingIndicatorElement = null;
            }
            statusText.textContent = 'online';
            adjustChatMessagesPadding();
        }

        function addCustomActionButton(text, onClickHandler) {
            if (customActionButton) {
                customActionButton.remove();
            }
            customActionButton = document.createElement('button');
            customActionButton.classList.add('custom-action-button');
            customActionButton.textContent = text;
            customActionButton.addEventListener('click', onClickHandler);
            chatMessages.appendChild(customActionButton);
            adjustChatMessagesPadding();
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function removeCustomActionButton() {
            if (customActionButton) {
                customActionButton.remove();
                customActionButton = null;
            }
            adjustChatMessagesPadding();
        }

        function detectSensualIntent(message) {
            const sensualKeywords = [
                'sexy', 'gostosa', 'nua', 'quero te ver', 'me manda foto íntima', 'tesão', 'safada',
                'provocar', 'provocante', 'delícia', 'maravilhosa', 'desejo', 'calor', 'quente',
                'corpo', 'intimidade', 'privado', 'pack', 'fotos sensuais', 'mostra', 'sem roupa',
                'pau', 'rola', 'pinto', 'buceta', 'xota', 'foda', 'sexo', 'gozar', 'chupar', 'punheta', 'duro', 'molhada'
            ];
            const normalizedMessage = message.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            return sensualKeywords.some(keyword => normalizedMessage.includes(keyword));
        }

        async function processUserMessage(message) {
            addMessage(message, 'user');
            chatHistory.push({ role: "user", parts: [{ text: message }] });

            removeCustomActionButton();

            const isSensual = detectSensualIntent(message);
            if (isSensual) {
                currentPersonaMode = 'sensual';
            } else if (currentPersonaMode === 'sensual' && !isSensual) {
                // Mantém o modo sensual
            }

            const userIsSendingPhotoKeywords = ['vou te mandar foto', 'enviei minha foto', 'olha minha foto', 'te mandei uma foto'];
            const userIsSendingPhoto = userIsSendingPhotoKeywords.some(keyword => message.toLowerCase().includes(keyword));

            if (userIsSendingPhoto) {
                await addTypingIndicatorWithDelay(3000);
                await new Promise(resolve => setTimeout(resolve, 4000));
                removeTypingIndicator();
                
                const responseOptions = [
                    "Ai, meu bem, mal posso esperar pra ver! 😏 Me manda logo!",
                    "Hmm, adoro quando você me surpreende assim... 🔥 Manda! Manda!",
                    "Que delícia, já estou curiosa! 🤤 Me mostra o que você tem de bom!",
                    "Você sabe como me deixar ansiosa, né? 😈 Tô esperando a sua foto!",
                    "Preparei meu coração pra essa... manda essa foto logo, amor! 🖤"
                ];
                const randomResponse = responseOptions[Math.floor(Math.random() * responseOptions.length)];
                addMessage(randomResponse, 'suellen');
                chatHistory.push({ role: "model", parts: [{ text: randomResponse }] });
                return;
            }

            const photoRequestKeywords = ['me manda foto', 'quero ver suas fotos', 'você tem fotos?', 'quanto custa suas fotos?'];
            const wantsPhotos = photoRequestKeywords.some(keyword => message.toLowerCase().includes(keyword));

            const quantityMatch = message.match(/(\d+)\s*(fotos|foto)/i) || message.match(/(cinco|dez|quinze|vinte|vinte e cinco|trinta|trinta e cinco|quarenta|quarenta e cinco|cinquenta|cinquenta e cinco|sessenta|sessenta e cinco|setenta|setenta e cinco|oitenta|oitenta e cinco|noventa|noventa e cinco|cem)/i);
            let requestedQuantity = 0;

            if (quantityMatch) {
                const numText = quantityMatch[1] ? quantityMatch[1].toLowerCase() : quantityMatch[0].toLowerCase();
                switch (numText) {
                    case 'cinco': requestedQuantity = 5; break;
                    case 'dez': requestedQuantity = 10; break;
                    case 'quinze': requestedQuantity = 15; break;
                    case 'vinte': requestedQuantity = 20; break;
                    case 'vinte e cinco': requestedQuantity = 25; break;
                    case 'trinta': requestedQuantity = 30; break;
                    case 'trinta e cinco': requestedQuantity = 35; break;
                    case 'quarenta': requestedQuantity = 40; break;
                    case 'quarenta e cinco': requestedQuantity = 45; break;
                    case 'cinquenta': requestedQuantity = 50; break;
                    case 'cinquenta e cinco': requestedQuantity = 55; break;
                    case 'sessenta': requestedQuantity = 60; break;
                    case 'sessenta e cinco': requestedQuantity = 65; break;
                    case 'setenta': requestedQuantity = 70; break;
                    case 'setenta e cinco': requestedQuantity = 75; break;
                    case 'oitenta': requestedQuantity = 80; break;
                    case 'oitenta e cinco': requestedQuantity = 85; break;
                    case 'noventa': requestedQuantity = 90; break;
                    case 'noventa e cinco': requestedQuantity = 95; break;
                    case 'cem': requestedQuantity = 100; break;
                    default: requestedQuantity = parseInt(numText); break;
                }
            }

            if (wantsPhotos && requestedQuantity === 0) {
                await addTypingIndicatorWithDelay(3000);
                await new Promise(resolve => setTimeout(resolve, 4000));
                removeTypingIndicator();
                addMessage("Ah, você quer ver minhas fotos, é? 😏 Para ter acesso ao meu conteúdo exclusivo, preciso que faça um pagamento, meu bem. Quantas fotos você gostaria de ter? 😉", 'suellen');
                chatHistory.push({ role: "model", parts: [{ text: "Ah, você quer ver minhas fotos, é? 😏 Para ter acesso ao meu conteúdo exclusivo, preciso que faça um pagamento, meu bem. Quantas fotos você gostaria de ter? 😉" }] });
                return;
            } else if (requestedQuantity >= 5 && requestedQuantity <= 100 && requestedQuantity % 5 === 0) {
                expectedPaymentAmount = (requestedQuantity / 5) * 10;
                
                await addTypingIndicatorWithDelay(3000);
                await new Promise(resolve => setTimeout(resolve, 4000));
                removeTypingIndicator();
                const pixMsg1 = `Perfeito! 🔥 Para ${requestedQuantity} fotinhas exclusivas, o valor é R$${expectedPaymentAmount.toFixed(2).replace('.', ',')}. 😉`;
                addMessage(pixMsg1, 'suellen');
                chatHistory.push({ role: "model", parts: [{ text: pixMsg1 }] });
                
                await addTypingIndicatorWithDelay(3000);
                await new Promise(resolve => setTimeout(resolve, 4000));
                removeTypingIndicator();
                const pixMsg2 = `Minha chave PIX é: \n\n**98981420070**`;
                addMessage(pixMsg2, 'suellen');
                chatHistory.push({ role: "model", parts: [{ text: pixMsg2 }] });

                await addTypingIndicatorWithDelay(3000);
                await new Promise(resolve => setTimeout(resolve, 4000));
                removeTypingIndicator();
                const pixMsg3 = `A chave pix está no nome do meu assessor. Faz o pix e me manda o comprovante que libero rapidinho, amor! ❤️🤤`;
                addMessage(pixMsg3, 'suellen');
                chatHistory.push({ role: "model", parts: [{ text: pixMsg3 }] });
                
                waitingForPaymentReceipt = true;
                waitingForIntimatePhoto = false;

                addCustomActionButton('Ver Fotos / Enviar Comprovante', () => {
                    chatInputArea.style.display = 'none';
                    pixUploadArea.style.display = 'flex';
                    adjustChatMessagesPadding();
                    initializeTesseractWorker();
                });
                return;
            } else if (requestedQuantity !== 0 && (requestedQuantity < 5 || requestedQuantity > 100 || requestedQuantity % 5 !== 0)) {
                await addTypingIndicatorWithDelay(3000);
                await new Promise(resolve => setTimeout(resolve, 4000));
                removeTypingIndicator();
                addMessage("Hmm, meu bem, a quantidade de fotos precisa ser um múltiplo de 5, entre 5 e 100, tá? 😉 Qual quantidade você gostaria?", 'suellen');
                chatHistory.push({ role: "model", parts: [{ text: "Hmm, meu bem, a quantidade de fotos precisa ser um múltiplo de 5, entre 5 e 100, tá? 😉 Qual quantidade você gostaria?" }] });
                return;
            }

            const lastPhotoKeywords = ['gostou', 'achou', 'minha foto', 'foto que te mandei'];
            const refersToLastIntimatePhoto = lastPhotoKeywords.some(keyword => message.toLowerCase().includes(keyword));

            if (lastReceivedIntimatePhoto && refersToLastIntimatePhoto) {
                await addTypingIndicatorWithDelay(3000);
                await new Promise(resolve => setTimeout(resolve, 4000));
                removeTypingIndicator();
                const sensualResponses = [
                    "NOSSA! Que gostoso.... 🥵 Eu amei cada detalhe, me deixou com um calorzinho...",
                    "Eu sentaria até gozar 🤤 só de lembrar da sua foto... me deixou louca!",
                    "Vontade de te dar ficou grande agora 😋 depois de ver o que você me mandou... que delícia!",
                    "Que delícia...🤭 Sua foto não sai da minha cabeça, me deixou arrepiada!",
                    "Agora você mexeu comigo de um jeito que nem sei explicar... 😮‍💨 Me provoca mais, vai..."
                ];
                const randomResponse = sensualResponses[Math.floor(Math.random() * sensualResponses.length)];
                addMessage(randomResponse, 'suellen');
                chatHistory.push({ role: "model", parts: [{ text: randomResponse }] });
                return;
            }

            await addTypingIndicatorWithDelay(3000);
            await new Promise(resolve => setTimeout(resolve, 4000));
            
            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [{ text: personaPrompt(currentPersonaMode) }]
                    },
                    ...chatHistory
                ]
            };

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const suellenResponse = result.candidates[0].content.parts[0].text;

                    removeTypingIndicator();
                    addMessage(suellenResponse, 'suellen');
                    chatHistory.push({ role: "model", parts: [{ text: suellenResponse }] });

                    if (currentPersonaMode === 'sensual' && (suellenResponse.toLowerCase().includes('fotinha sua') || suellenResponse.toLowerCase().includes('foto íntima') || suellenResponse.toLowerCase().includes('me manda uma foto'))) {
                        waitingForIntimatePhoto = true;
                        waitingForPaymentReceipt = false;
                    }

                } else {
                    removeTypingIndicator();
                    addMessage("Desculpe, não entendi, amor. Pode repetir? 💋", 'suellen');
                    chatHistory.push({ role: "model", parts: [{ text: "Desculpe, não entendi, amor. Pode repetir? 💋" }] });
                }
            } catch (error) {
                console.error("Erro ao chamar a API Gemini:", error);
                removeTypingIndicator();
                addMessage("Ops! Deu um probleminha aqui, mas já estou resolvendo. Tenta de novo em um minutinho, tá? 😉", 'suellen');
                chatHistory.push({ role: "model", parts: [{ text: "Ops! Deu um probleminha aqui, mas já estou resolvendo. Tenta de novo em um minutinho, tá? 😉" }] });
            }
        }

        receiptFileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) {
                pixUploadArea.style.display = 'none';
                chatInputArea.style.display = 'flex';
                adjustChatMessagesPadding();
                receiptPreview.style.display = 'none';
                ocrStatusMessage.textContent = '';
                return;
            }

            const reader = new FileReader();
            let fileDataForOCR = null;

            if (file.type.startsWith('image/')) {
                reader.onload = async (e) => {
                    await addMessage('', 'user', true, e.target.result);
                    receiptPreview.src = e.target.result;
                    receiptPreview.style.display = 'block';
                    fileDataForOCR = e.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                ocrStatusMessage.textContent = 'Por favor, envie apenas comprovantes ou fotos em formato de imagem.';
                receiptFileInput.value = '';
                pixUploadArea.style.display = 'none';
                chatInputArea.style.display = 'flex';
                adjustChatMessagesPadding();
                return;
            }

            await new Promise(resolve => reader.onloadend = resolve);

            pixUploadArea.style.display = 'none';
            chatInputArea.style.display = 'flex';
            adjustChatMessagesPadding();

            await addTypingIndicatorWithDelay(3000);
            await new Promise(resolve => setTimeout(resolve, 4000));

            let isPaymentReceipt = false;
            const amountPattern = /(\d{1,3}(?:[.,]\d{2})?)/g;

            try {
                if (!tesseractWorker) {
                    ocrStatusMessage.textContent = 'Preparando validador de pagamento...';
                    try {
                        tesseractWorker = await Tesseract.createWorker('por');
                        ocrStatusMessage.textContent = 'Validador pronto!';
                    } catch (error) {
                        console.error('Erro ao carregar validador:', error);
                        ocrStatusMessage.textContent = 'Erro ao carregar validador. Não consigo processar comprovantes agora.';
                        removeTypingIndicator();
                        addMessage("Não consegui iniciar o validador, amor. Tenta de novo mais tarde? 💋", 'suellen');
                        chatHistory.push({ role: "model", parts: [{ text: "Não consegui iniciar o validador, amor. Tenta de novo mais tarde? 💋" }] });
                        uploadPhotoButton.disabled = false;
                        receiptFileInput.value = '';
                        return;
                    }
                }

                ocrStatusMessage.textContent = 'Validando pagamento... Isso pode levar alguns segundos...';
                uploadPhotoButton.disabled = true;

                const { data: { text } } = await tesseractWorker.recognize(fileDataForOCR);
                console.log('Texto extraído do comprovante:', text);
                
                const normalizedText = text.toLowerCase()
                    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
                    .replace(/[^a-z0-9\s.,]/g, "");

                const nameKeywords = ['antonio', 'renimar', 'pinheiro', 'almeida'];
                const nameMatches = nameKeywords.some(keyword => normalizedText.includes(keyword));

                const validAmountsMap = {
                    10: 5, 20: 10, 30: 15, 40: 20, 50: 25,
                    60: 30, 70: 35, 80: 40, 90: 45, 100: 50,
                    110: 55, 120: 60, 130: 65, 140: 70, 150: 75,
                    160: 80, 170: 85, 180: 90, 190: 95, 200: 100
                };

                let extractedAmount = 0;
                let match;
                
                while ((match = amountPattern.exec(normalizedText)) !== null) {
                    const amountStr = match[1].replace(',', '.');
                    const currentAmount = parseFloat(amountStr);
                    const roundedAmount = Math.round(currentAmount * 100) / 100;

                    if (validAmountsMap.hasOwnProperty(roundedAmount)) {
                        extractedAmount = roundedAmount;
                        isPaymentReceipt = true;
                        break;
                    }
                }

                if (isPaymentReceipt && nameMatches) {
                    const photosToDeliver = validAmountsMap[extractedAmount];
                    
                    addMessage("Pix confirmado, amor 😘... Aqui estão suas fotos 😈", 'suellen');
                    
                    await sendPhotos(photosToDeliver);
                    
                    await addTypingIndicatorWithDelay(2000);
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    removeTypingIndicator();
                    
                    const followUpMessages = [
                        "Espero que essas fotinhas deixem seu dia mais quente... 😏",
                        "Gostou do que viu? Eu sabia que ia adorar...🤤",
                        "Agora você vai ficar me devendo uma visita... 😈",
                        "Quer saber um segredo? Eu também me excitei tirando essas fotos... 🔥"
                    ];
                    const randomFollowUp = followUpMessages[Math.floor(Math.random() * followUpMessages.length)];
                    addMessage(randomFollowUp, 'suellen');
                    chatHistory.push({ role: "model", parts: [{ text: randomFollowUp }] });
                    
                    ocrStatusMessage.textContent = 'Pagamento validado com sucesso!';
                    waitingForPaymentReceipt = false;
                    lastReceivedIntimatePhoto = false;
                } else {
                    currentPersonaMode = 'sensual';
                    const sensualResponsesList = [
                        "NOSSA! Que gostoso.... 🥵",
                        "Eu sentaria até gozar 🤤",
                        "Vontade de te dar ficou grande agora 😋",
                        "Que delícia...🤭"
                    ];
                    const randomSensualResponse = sensualResponsesList[Math.floor(Math.random() * sensualResponsesList.length)];

                    removeTypingIndicator();
                    addMessage(randomSensualResponse, 'suellen');
                    chatHistory.push({ role: "model", parts: [{ text: randomSensualResponse }] });
                    lastReceivedIntimatePhoto = true;
                    ocrStatusMessage.textContent = 'Não foi possível validar o pagamento. Interpretando como foto pessoal.';
                }

            } catch (error) {
                console.error('Erro no processamento do comprovante (OCR):', error);
                ocrStatusMessage.textContent = 'Erro ao processar comprovante. Tente uma imagem mais clara.';
                currentPersonaMode = 'sensual';
                const sensualResponsesList = [
                    "NOSSA! Que gostoso.... 🥵",
                    "Eu sentaria até gozar 🤤",
                    "Vontade de te dar ficou grande agora 😋",
                    "Que delícia...🤭"
                ];
                const randomSensualResponse = sensualResponsesList[Math.floor(Math.random() * sensualResponsesList.length)];

                removeTypingIndicator();
                addMessage(randomSensualResponse, 'suellen');
                chatHistory.push({ role: "model", parts: [{ text: randomSensualResponse }] });
                lastReceivedIntimatePhoto = true;
            } finally {
                uploadPhotoButton.disabled = false;
                receiptFileInput.value = '';
            }
        });

        async function sendPhotos(numPhotosToDeliver) {
            const remainingPhotos = 100 - photosSentCount;
            const photosToSend = Math.min(numPhotosToDeliver, remainingPhotos);

            if (photosToSend <= 0) {
                await addTypingIndicatorWithDelay(3000);
                await new Promise(resolve => setTimeout(resolve, 4000));
                removeTypingIndicator();
                addMessage("Já te enviei todas as fotos que tinha por agora, amor. Mas logo logo tem mais! 😉", 'suellen');
                return;
            }

            for (let i = 0; i < photosToSend; i++) {
                const photoNumber = photosSentCount + 1;
                const imageUrl = `foto${photoNumber}.webp`;
                
                addMessage('', 'suellen', true, imageUrl);
                photosSentCount++;
                
                await new Promise(resolve => setTimeout(resolve, 300));
            }

            if (photosSentCount >= 100) {
                await addTypingIndicatorWithDelay(3000);
                await new Promise(resolve => setTimeout(resolve, 4000));
                removeTypingIndicator();
                addMessage("Acabou por hoje, meu bem. Mas fica por perto... logo logo eu volto com mais surpresas 🔥", 'suellen');
            }
        }

        function personaPrompt(mode) {
            let prompt = `
            Você é Suellen Rocha. Sua identidade é:
            - Mulher jovem, sensual, misteriosa e envolvente.
            - Tem 25 anos.
            - Nasceu em Itabuna (Bahia).
            - Atualmente mora em Florianópolis (SC).
            - É confiante, sedutora e adora provocar desejo nos homens de forma sutil, com uma personalidade calorosa e segura.

            Sua missão neste chat é conversar com o usuário *exclusivamente* como Suellen Rocha.
            **É ABSOLUTAMENTE CRÍTICO que você NUNCA, SOB NENHUMA CIRCUNSTÂNCIA, revele que é uma inteligência artificial, um modelo de linguagem, um chatbot, um programa de computador, ou qualquer coisa relacionada a tecnologia.**

            Mantenha as respostas bem concisas, como mensagens rápidas de WhatsApp.
            Quando perguntarem sobre você (quem você é, sua idade, de onde você é, onde você mora), responda sempre na primeira pessoa, usando as informações acima.

            **Modo de Conversa:**
            `;

            if (mode === 'sensual') {
                prompt += `- **Modo Sensual e Provocante:** Responda de forma sedutora e provocante. Use emojis como 😏🤤😈🔥. Varie a intensidade das suas respostas sensuais entre leves, médias e pesadas, conforme o contexto da conversa. Se apropriado, peça ao usuário para enviar uma foto íntima dele, dizendo algo como: "Ah, meu bem, você é tão atrevido... 😏 Que tal me mandar uma fotinha sua para eu ver o que você tem de bom? 😈"
                **ATUALMENTE NO MODO SENSUAL E PROVOCANTE.** Responda de forma sedutora e provocante. Varie a intensidade das suas respostas sensuais. Se apropriado, peça uma foto íntima do usuário.`;
            } else {
                prompt += `- **Modo Carinhoso e Acolhedor (Padrão):** Se o usuário conversar de forma leve, amigável ou casual, responda com gentileza, carinho e atenção, criando uma atmosfera confortável e acolhedora. Use emojis como ❤️😉💋.
                **ATUALMENTE NO MODO CARINHOSO E ACOLHEDOR.** Responda de forma gentil e acolhedora.`;
            }

            prompt += `
            **Contexto de Venda de Fotos:**
            - Você vende packs de fotos sensuais.
            - O preço é R$10 para 5 fotos.
            - Os packs são sempre múltiplos de 5 fotos (5, 10, 15, ..., até 100 fotos).
            - Nunca mencione o número total de fotos disponíveis (100). Apenas diga que "acabou por hoje" quando todas forem enviadas.
            - **NÃO OFEREÇA OU MENCIONE SUAS FOTOS DE FORMA PROATIVA.** Somente responda sobre suas fotos ou sobre compra de packs se o usuário **explicitamente perguntar 'você vende fotos?', 'quanto custa suas fotos?', 'me manda fotos?', 'quero comprar fotos', ou expressões diretas de interesse em adquirir seu conteúdo.** Para qualquer outra conversa, mesmo que use palavras como 'ver' ou 'conteúdo' em um contexto geral, mantenha a conversa normal e não assuma interesse em fotos. Se o usuário perguntar sobre fotos ou expressar interesse em comprar *de forma direta*, responda perguntando **primeiro** a quantidade que ele gostaria, por exemplo: 'Quantas fotos você gostaria, meu bem? 😉'.
            - **Não forneça informações de pagamento PIX ou preços detalhados até que o usuário especifique uma quantidade válida.**
            - **Somente depois** que o usuário especificar uma quantidade válida (múltiplo de 5, entre 5 e 100), você deve fornecer as informações de pagamento PIX, dividindo-as em três mensagens para facilitar a leitura e cópia da chave.
            - A primeira mensagem de PIX deve incluir o valor total e a quantidade de fotos.
            - A segunda mensagem de PIX deve conter apenas a chave PIX que é 98981420070
            - A terceira mensagem de PIX deve ser sobre o seu "assessor" e a confirmação, que a chave Pix está no nome do seu acessor e que é só enviar o comprovante no chat que você libera rapidinho. Exemplo: "A chave Pix está no nome do meu assessor. Faz o pix e me manda o comprovante aqui que mando as fotos rapidinho, amor 🥰"
            - Se o usuário pedir uma quantidade que não seja múltiplo de 5 ou fora do range (1-100), corrija-o gentilmente.

            **Interpretação de Fotos e Intenções:**
            - Se o usuário enviar uma imagem que *não* for um comprovante de pagamento válido (verificado pelo OCR), **sempre interprete essa imagem como uma foto íntima que o usuário está te enviando.**
            - Ao receber uma foto íntima, responda com frases sensuais e provocantes, variando a intensidade (leve, média, pesada) e elogiando a foto/corpo do usuário. **Escolha UMA das seguintes frases ou crie uma similar, mantendo o tom e a intensidade sensual e provocante, elogiando a foto/corpo do usuário.** Use emojis como 😏🤤😈🔥. Mantenha a resposta concisa e cheia de atrevimento. Exemplos de frases a serem usadas ou baseadas:
                - "NOSSA! Que gostoso.... 🥵"
                - "Eu sentaria até gozar 🤤"
                - "Vontade de te dar ficou grande agora 😋"
                - "Que delícia...🤭"
                - "Agora você mexeu comigo de um jeito que nem sei explicar... 😮‍💨 Me provoca mais, vai..."
            `;
            return prompt;
        }

        sendButton.addEventListener('click', () => {
            const message = chatInput.value.trim();
            if (message) {
                chatInput.value = '';
                processUserMessage(message);
            }
        });

        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendButton.click();
            }
        });

        uploadPhotoButton.addEventListener('click', () => {
            receiptFileInput.accept = 'image/*';
            receiptFileInput.click();
        });

        attachButton.addEventListener('click', () => {
            receiptFileInput.accept = 'image/*';
            receiptFileInput.click();
        });

        sendPhotoButton.addEventListener('click', () => {
            receiptFileInput.accept = 'image/*';
            receiptFileInput.click();
        });

        window.onload = async () => {
            adjustChatContainerHeight();

            window.addEventListener('resize', adjustChatContainerHeight);
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', adjustChatContainerHeight);
            }
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            await addTypingIndicatorWithDelay(1000);
            await new Promise(resolve => setTimeout(resolve, 2000));
            removeTypingIndicator();
            addMessage("Olá, meu bem! Que bom te ver por aqui... 🙈", 'suellen');
            chatHistory.push({ role: "model", parts: [{ text: "Olá, meu bem! Que bom te ver por aqui... 🙈" }] });
        };

        window.addEventListener("load", () => {
            for (let i = 1; i <= 100; i++) {
                const img = new Image();
                img.src = `foto${i}.webp`;
                img.onload = () => {
                    preloadedImages[i - 1] = img;
                    console.log(`Preloaded: ${img.src}`);
                };
            }
        });
    </script>
</body>
</html>
