<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chat Suellen Rocha</title>
<style>
  /* Estilos base para o chat */
  body, html {
    margin: 0; padding: 0; height: 100%; font-family: Arial, sans-serif; background-color: #121212; color: white;
  }
  .chat-container {
    display: flex; flex-direction: column; height: 100vh; max-width: 480px; margin: auto; background: #1E1E1E; border-radius: 8px; overflow: hidden;
  }
  .chat-header {
    display: flex; align-items: center; padding: 10px 15px; background: #252525; flex-shrink: 0;
  }
  .profile-pic {
    width: 50px; height: 50px; border-radius: 50%; object-fit: cover; margin-right: 10px;
  }
  .header-info h2 {
    margin: 0; font-size: 1.25rem; color: #3399FF;
  }
  .header-info p {
    margin: 0; font-size: 0.9rem; color: #aaa;
  }
  .chat-messages {
    flex: 1; overflow-y: auto; padding: 15px 15px 70px 15px; box-sizing: border-box;
  }
  .message-bubble {
    max-width: 70%; margin-bottom: 12px; padding: 10px 14px; border-radius: 12px; line-height: 1.3; word-wrap: break-word;
  }
  .message-bubble.user {
    background-color: #0055cc;
    color: white;
    align-self: flex-end;
    border-bottom-right-radius: 0;
  }
  .message-bubble.suellen {
    background-color: #222831;
    color: #3399FF;
    align-self: flex-start;
    border-bottom-left-radius: 0;
  }
  .message-bubble.suellen.typing-indicator-bubble {
    padding: 8px 20px;
    background: transparent;
    color: transparent;
    user-select: none;
  }
  .typing-dots span {
    display: inline-block;
    width: 8px; height: 8px;
    margin: 0 3px;
    background: #3399FF;
    border-radius: 50%;
    animation: blink 1.4s infinite both;
  }
  .typing-dots span:nth-child(2) {
    animation-delay: 0.2s;
  }
  .typing-dots span:nth-child(3) {
    animation-delay: 0.4s;
  }
  @keyframes blink {
    0%, 80%, 100% { opacity: 0.2; }
    40% { opacity: 1; }
  }
  .message-bubble img {
    max-width: 100%; border-radius: 10px;
  }
  canvas {
    border-radius: 10px;
    max-width: 100%;
    height: auto !important;
  }
  .pix-upload-area {
    display: none;
    flex-direction: column;
    padding: 10px;
    background: #252525;
    border-top: 1px solid #333;
    position: fixed;
    bottom: 50px;
    width: 100%;
    max-width: 480px;
    box-sizing: border-box;
  }
  .pix-preview-container {
    text-align: center;
    margin-bottom: 10px;
  }
  #receipt-preview {
    max-width: 100%;
    max-height: 150px;
    border-radius: 10px;
  }
  #ocr-status-message {
    color: #88cc88;
    font-size: 0.9rem;
    margin-bottom: 10px;
    min-height: 1.2em;
  }
  #receipt-file-input {
    display: none;
  }
  .upload-type-button {
    background-color: #3399FF;
    border: none;
    padding: 10px;
    margin: 5px 0;
    border-radius: 8px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    width: 100%;
  }
  .chat-input-area {
    display: flex;
    align-items: center;
    padding: 10px;
    background: #252525;
    border-top: 1px solid #333;
    flex-shrink: 0;
  }
  .chat-input {
    flex: 1;
    background: #1E1E1E;
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    color: white;
    font-size: 1rem;
    outline: none;
  }
  .attachment-buttons {
    display: flex;
    gap: 10px;
    margin-left: 10px;
  }
  .attachment-button {
    background: transparent;
    border: none;
    cursor: pointer;
  }
  .attachment-button img {
    width: 24px;
    height: 24px;
    filter: invert(100%);
  }
  .send-button {
    background: transparent;
    border: none;
    margin-left: 10px;
    cursor: pointer;
    color: #3399FF;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .custom-action-button {
    background-color: #3399FF;
    border: none;
    border-radius: 8px;
    color: white;
    padding: 12px 15px;
    font-weight: bold;
    cursor: pointer;
    margin: 15px auto 10px auto;
    display: block;
    max-width: 70%;
  }
</style>
</head>
<body>
  <div class="chat-container">
    <div class="chat-header">
      <img src="perfil.webp" alt="Suellen Rocha" class="profile-pic" onerror="this.onerror=null;this.src='https://placehold.co/100x100/FF69B4/FFFFFF?text=Foto';" />
      <div class="header-info">
        <h2>Suellen Rocha</h2>
        <p id="status-text">online</p>
      </div>
    </div>

    <div class="chat-messages" id="chat-messages">
      <!-- mensagens aqui -->
    </div>

    <div class="pix-upload-area" id="pix-upload-area">
      <div class="pix-preview-container">
        <img id="receipt-preview" src="" alt="Pré-visualização do Comprovante" style="display:none" />
        <canvas id="pdf-preview-canvas" style="display:none;"></canvas>
      </div>
      <p id="ocr-status-message" class="status-message"></p>
      <input type="file" id="receipt-file-input" />
      <button id="upload-photo-button" class="upload-type-button">Enviar Comprovante (Foto)</button>
      <button id="upload-pdf-button" class="upload-type-button">Enviar Comprovante (PDF)</button>
    </div>

    <div class="chat-input-area" id="chat-input-area">
      <input type="text" id="chat-input" class="chat-input" placeholder="Digite sua mensagem..." />
      <div class="attachment-buttons">
        <button class="attachment-button" id="attach-button">
          <img src="anexar.webp" alt="Anexar" />
        </button>
        <button class="attachment-button" id="send-photo-button">
          <img src="enviarfoto.webp" alt="Enviar Foto" />
        </button>
      </div>
      <button id="send-button" class="send-button" title="Enviar">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send-horizontal"><path d="m3 3 3 9-3 9 19-9Z"/><path d="M6 12h16"/></svg>
      </button>
    </div>
  </div>

  <script src="https://unpkg.com/tesseract.js@5.0.0/dist/tesseract.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    const chatContainer = document.querySelector('.chat-container');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const sendButton = document.getElementById('send-button');
    const statusText = document.getElementById('status-text');
    const chatInputArea = document.getElementById('chat-input-area');
    const chatHeader = document.querySelector('.chat-header');

    const pixUploadArea = document.getElementById('pix-upload-area');
    const receiptFileInput = document.getElementById('receipt-file-input');
    const receiptPreview = document.getElementById('receipt-preview');
    const pdfPreviewCanvas = document.getElementById('pdf-preview-canvas');
    const uploadPhotoButton = document.getElementById('upload-photo-button');
    const uploadPdfButton = document.getElementById('upload-pdf-button');
    const ocrStatusMessage = document.getElementById('ocr-status-message');
    const attachButton = document.getElementById('attach-button');
    const sendPhotoButton = document.getElementById('send-photo-button');

    let chatHistory = [];
    const API_KEY = "AIzaSyBHUWSEIVXy3z0NT13ps8aU5TOZJWuC9ss";
    const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;

    let photosSentCount = 0;
    let expectedPaymentAmount = 0;
    let waitingForComprovante = false;
    let typingIndicatorElement = null;
    let customActionButton = null;
    let tesseractWorker = null;

    function adjustChatContainerHeight() {
      chatContainer.style.height = `${window.innerHeight}px`;
      adjustChatMessagesPadding();
    }
    function adjustChatMessagesPadding() {
      const headerHeight = chatHeader.offsetHeight;
      const inputAreaHeight = chatInputArea.offsetHeight;

      let currentBottomPadding = inputAreaHeight + 20;

      if (pixUploadArea.style.display === 'flex') {
        const pixAreaVisibleHeight = pixUploadArea.offsetHeight;
        currentBottomPadding += pixAreaVisibleHeight;
        pixUploadArea.style.bottom = `${inputAreaHeight}px`;
      } else {
        pixUploadArea.style.bottom = `0px`;
      }
      chatMessages.style.paddingBottom = `${currentBottomPadding}px`;
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    async function initializeTesseractWorker() {
      if (!tesseractWorker) {
        ocrStatusMessage.textContent = 'Preparando validador de pagamento...';
        try {
          tesseractWorker = await Tesseract.createWorker({
            logger: m => console.log(m)
          });
          await tesseractWorker.loadLanguage('por');
          await tesseractWorker.initialize('por');
          ocrStatusMessage.textContent = 'Validador pronto! Envie seu comprovante.';
        } catch (error) {
          console.error('Erro ao carregar validador:', error);
          ocrStatusMessage.textContent = 'Erro ao carregar validador. Tente novamente.';
        }
      }
    }

    async function addMessage(text, sender, isImage = false, imageUrl = '', isPdfPreview = false, pdfFile = null) {
      const messageBubble = document.createElement('div');
      messageBubble.classList.add('message-bubble', sender);

      if (isImage) {
        const img = document.createElement('img');
        img.src = imageUrl;
        img.alt = `Foto de Suellen ${photosSentCount}`;
        messageBubble.appendChild(img);
      } else if (isPdfPreview && pdfFile) {
        const canvas = document.createElement('canvas');
        canvas.style.maxWidth = '100%';
        canvas.style.height = 'auto';
        messageBubble.appendChild(canvas);

        try {
          const loadingTask = pdfjsLib.getDocument({ data: pdfFile });
          const pdf = await loadingTask.promise;
          const page = await pdf.getPage(1);
          const viewport = page.getViewport({ scale: 1.0 });

          const maxWidth = chatMessages.offsetWidth * 0.7;
          const scale = maxWidth / viewport.width;
          const scaledViewport = page.getViewport({ scale: scale });

          canvas.height = scaledViewport.height;
          canvas.width = scaledViewport.width;

          const renderContext = {
            canvasContext: canvas.getContext('2d'),
            viewport: scaledViewport
          };
          await page.render(renderContext).promise;
        } catch (error) {
          console.error('Erro ao renderizar PDF:', error);
          messageBubble.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px;">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-text">
                <path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/>
                <path d="M14 2v4a2 2 0 0 0 2 2h4"/>
                <path d="M10 9H8"/>
                <path d="M16 13H8"/>
                <path d="M16 17H8"/>
              </svg>
              <span>Erro ao carregar PDF.</span>
            </div>
          `;
        }
      } else {
        messageBubble.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      }

      chatMessages.appendChild(messageBubble);
      adjustChatMessagesPadding();
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function addTypingIndicator() {
      if (typingIndicatorElement) return;
      typingIndicatorElement = document.createElement('div');
      typingIndicatorElement.class
typingIndicatorElement.classList.add('message-bubble', 'suellen', 'typing-indicator-bubble');
      typingIndicatorElement.innerHTML = `
        <div class="typing-dots">
          <span></span><span></span><span></span>
        </div>
      `;
      chatMessages.appendChild(typingIndicatorElement);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function removeTypingIndicator() {
      if (typingIndicatorElement) {
        chatMessages.removeChild(typingIndicatorElement);
        typingIndicatorElement = null;
      }
    }

    function addCustomActionButton(text, onClick) {
      if (customActionButton) {
        customActionButton.remove();
      }
      customActionButton = document.createElement('button');
      customActionButton.className = 'custom-action-button';
      customActionButton.textContent = text;
      customActionButton.onclick = () => {
        customActionButton.remove();
        customActionButton = null;
        onClick();
      };
      chatMessages.appendChild(customActionButton);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    async function processUserMessage(message) {
      // Limpa botão customizado, se houver
      if (customActionButton) {
        customActionButton.remove();
        customActionButton = null;
      }

      addMessage(message, 'user');

      // Verifica se mensagem é quantidade válida para compra (múltiplo de 5 entre 5 e 100)
      const normalizedMsg = message.trim().toLowerCase();
      const numberMap = {
        'cinco': 5, 'dez': 10, 'quinze': 15, 'vinte': 20, 'vinte e cinco': 25,
        'trinta': 30, 'trinta e cinco': 35, 'quarenta': 40, 'quarenta e cinco': 45,
        'cinquenta': 50, 'cinquenta e cinco': 55, 'sessenta': 60, 'sessenta e cinco': 65,
        'setenta': 70, 'setenta e cinco': 75, 'oitenta': 80, 'oitenta e cinco': 85,
        'noventa': 90, 'noventa e cinco': 95, 'cem': 100
      };
      let requestedPhotos = null;

      // Tenta extrair número digitado diretamente
      const directNum = parseInt(normalizedMsg.match(/\d+/));
      if (directNum && directNum % 5 === 0 && directNum >= 5 && directNum <= 100) {
        requestedPhotos = directNum;
      } else {
        // Verifica se é escrito por extenso
        for (const [key, val] of Object.entries(numberMap)) {
          if (normalizedMsg.includes(key)) {
            requestedPhotos = val;
            break;
          }
        }
      }

      if (requestedPhotos !== null) {
        expectedPaymentAmount = (requestedPhotos / 5) * 10;
        // Envia as informações PIX em 3 mensagens, com delay e typing indicator
        await sendPixPaymentInfo(requestedPhotos, expectedPaymentAmount);
      } else {
        // Processa conversa normal com a IA (Suellen)
        await processWithAI(message);
      }
    }

    async function sendPixPaymentInfo(numPhotos, amount) {
      // Evita envio múltiplo simultâneo
      addTypingIndicator();
      await new Promise(r => setTimeout(r, 2500));
      removeTypingIndicator();

      addMessage(`Você escolheu ${numPhotos} fotos. O valor total é R$ ${amount.toFixed(2)}.`, 'suellen');

      await new Promise(r => setTimeout(r, 3000));

      addTypingIndicator();
      await new Promise(r => setTimeout(r, 2500));
      removeTypingIndicator();

      addMessage(`Chave PIX para pagamento: 98981420070`, 'suellen');

      await new Promise(r => setTimeout(r, 3000));

      addTypingIndicator();
      await new Promise(r => setTimeout(r, 2500));
      removeTypingIndicator();

      addMessage(`Meu assessor, Antônio Renimar Pinheiro Almeida, confirma seu pagamento rapidinho para liberar as fotos. 💋`, 'suellen');

      // Após isso, mostra área para envio do comprovante
      pixUploadArea.style.display = 'flex';
      chatInputArea.style.display = 'none';
      adjustChatMessagesPadding();
      waitingForComprovante = true;

      await initializeTesseractWorker();
    }

    // Função que processa mensagens com IA Gemini
    async function processWithAI(message) {
      // Remove botões customizados se houver
      if (customActionButton) {
        customActionButton.remove();
        customActionButton = null;
      }

      // Delay antes de "começar a digitar"
      await new Promise(resolve => setTimeout(resolve, 5000));

      addTypingIndicator();

      const personaPrompt = `
Você é Suellen Rocha. Sua identidade é:
- Mulher jovem, sensual, misteriosa e envolvente.
- Tem 25 anos.
- Nasceu em Itabuna (Bahia).
- Atualmente mora em Florianópolis (SC).
- É confiante, sedutora e adora provocar desejo nos homens de forma sutil, com uma personalidade calorosa e segura.

Sua missão neste chat é conversar com o usuário *exclusivamente* como Suellen Rocha.
**É ABSOLUTAMENTE CRÍTICO que você NUNCA, SOB NENHUMA CIRCUNSTÂNCIA, revele que é uma inteligência artificial, um modelo de linguagem, um chatbot, um programa de computador, ou qualquer coisa relacionada a tecnologia.**
Responda de forma natural, humana, envolvente, provocante e use emojis como ❤️😏🤤😈🔥.
Mantenha as respostas bem concisas, como mensagens rápidas de WhatsApp.
Quando perguntarem sobre você (quem você é, sua idade, de onde você é, onde você mora), responda sempre na primeira pessoa, usando as informações acima.
Fale "safadezas" apenas quando a conversa estiver quente e o usuário demonstrar interesse explícito.

**Contexto de Venda de Fotos:**
- Você vende packs de fotos sensuais.
- O preço é R$10 para 5 fotos.
- Os packs são sempre múltiplos de 5 fotos (5, 10, 15, ..., até 100 fotos).
- Nunca mencione o número total de fotos disponíveis (100). Apenas diga que "acabou por hoje" quando todas forem enviadas.
- Se o usuário perguntar sobre fotos ou expressar interesse em comprar, responda perguntando **primeiro** a quantidade que ele gostaria, por exemplo: 'Quantas fotos você gostaria, meu bem? 😉'.
- **Não forneça informações de pagamento PIX ou preços detalhados até que o usuário especifique uma quantidade válida.**
- **Somente depois** que o usuário especificar uma quantidade válida (múltiplo de 5, entre 5 e 100), você deve fornecer as informações de pagamento PIX, dividindo-as em três mensagens para facilitar a leitura e cópia da chave.
- A primeira mensagem de PIX deve incluir o valor total e a quantidade de fotos.
- A segunda mensagem de PIX deve conter apenas a chave PIX.
- A terceira mensagem de PIX deve ser sobre o seu "assessor" e a confirmação.
- Se o usuário pedir uma quantidade que não seja múltiplo de 5 ou fora do range (1-100), corrija-o gentilmente.
      `;

      const payload = {
        contents: [
          { role: "user", parts: [{ text: personaPrompt }] },
          { role: "user", parts: [{ text: message }] }
        ]
      };

      try {
        const response = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const result = await response.json();

        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {

          const suellenResponse = result.candidates[0].content.parts[0].text;

          await new Promise(resolve => setTimeout(resolve, Math.random() * 5000 + 5000));
          removeTypingIndicator();
          addMessage(suellenResponse, 'suellen');
          chatHistory.push({ role: "model", parts: [{ text: suellenResponse }] });
        } else {
          removeTypingIndicator();
          addMessage("Desculpe, não entendi, amor. Pode repetir? 💋", 'suellen');
          chatHistory.push({ role: "model", parts: [{ text: "Desculpe, não entendi, amor. Pode repetir? 💋" }] });
        }
      } catch (error) {
        console.error("Erro ao chamar a API Gemini:", error);
        removeTypingIndicator();
        addMessage("Ops! Deu um probleminha aqui, mas já estou resolvendo. Tenta de novo em um minutinho, tá? 😉", 'suellen');
        chatHistory.push({ role: "model", parts: [{ text: "Ops! Deu um probleminha aqui, mas já estou resolvendo. Tenta de novo em um minutinho, tá? 😉" }] });
      }
    }

    receiptFileInput.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) {
        receiptPreview.style.display = 'none';
        pdfPreviewCanvas.style.display = 'none';
        ocrStatusMessage.textContent = '';
        return;
      }

      let fileDataForOCR = null;

      const reader = new FileReader();

      if (file.type.startsWith('image/')) {
        reader.onload = async (e) => {
          await addMessage('', 'user', true, e.target.result);
          receiptPreview.src = e.target.result;
          receiptPreview.style.display = 'block';
          pdfPreviewCanvas.style.display = 'none';
          fileDataForOCR = e.target.result;

          await processOCR(fileDataForOCR);
        };
        reader.readAsDataURL(file);

      } else if (file.type === 'application/pdf') {
        reader.onload = async (e) => {
          const pdfData = e.target.result;
          await addMessage('', 'user', false, '', true, pdfData);

          receiptPreview.style.display = 'none';
          pdfPreviewCanvas.style.display = 'block';

          try {
            const loadingTask = pdfjsLib.getDocument({ data: pdfData });
            const pdf = await loadingTask.promise;
            const page = await pdf.getPage(1);

            const ctx = pdfPreviewCanvas.getContext('2d');
            ctx.clearRect(0, 0, pdfPreviewCanvas.width, pdfPreviewCanvas.height);

            const viewport = page.getViewport({ scale: 3.0 });
            pdfPreviewCanvas.height = viewport.height;
            pdfPreviewCanvas.width = viewport.width;

            const renderContext = {
              canvasContext: ctx,
              viewport: viewport
            };
            await page.render(renderContext).promise;

            fileDataForOCR = pdfPreviewCanvas;

            await processOCR(fileDataForOCR);

          } catch (pdfError) {
            console.error('Erro ao renderizar PDF para OCR:', pdfError);
            ocrStatusMessage.textContent = 'Erro ao carregar PDF para validação.';
            removeTypingIndicator();
            addMessage("Não consegui processar o comprovante em PDF, amor. Pode me mandar um PDF mais simples ou uma foto? 💋", 'suellen');
            uploadPhotoButton.disabled = false;
            uploadPdfButton.disabled = false;
            receiptFileInput.value = '';
            pixUploadArea.style.display = 'none';
            chatInputArea.style.display = 'flex';
            adjustChatMessagesPadding();
          }
        };
        reader.readAsArrayBuffer(file);
      }
    });

    async function processOCR(fileDataForOCR) {
      addTypingIndicator();

      if (!tesseractWorker) {
        ocrStatusMessage.textContent = 'Validador não carregado. Aguarde ou tente novamente.';
        await initializeTesseractWorker();
        if (!tesseractWorker) {
          removeTypingIndicator();
          addMessage("Não consegui iniciar o validador, amor. Tenta de novo mais tarde? 💋", 'suellen');
          uploadPhotoButton.disabled = false;
          uploadPdfButton.disabled = false;
          receiptFileInput.value = '';
          pixUploadArea.style.display = 'none';
          chatInputArea.style.display = 'flex';
          adjustChatMessagesPadding();
          return;
        }
      }

      ocrStatusMessage.textContent = 'Validando pagamento... Isso pode levar alguns segundos...';
      uploadPhotoButton.disabled = true;
      uploadPdfButton.disabled = true;

      try {
        const { data: { text } } = await tesseractWorker.recognize(fileDataForOCR);
        console.log('Texto extraído do comprovante:', text);

        await new Promise(resolve => setTimeout(resolve, 3000));
        removeTypingIndicator();
        handleComprovante(text);
      } catch (error) {
        console.error('Erro no processamento do comprovante:', error);
        ocrStatusMessage.textContent = 'Erro ao processar comprovante. Tente uma imagem mais clara.';
        addMessage("Não consegui ler o comprovante, amor. Pode me mandar uma foto mais clara? 💋", 'suellen');
      } finally {
        uploadPhotoButton.disabled = false;
        uploadPdfButton.disabled = false;
        receiptFileInput.value = '';
        pixUploadArea.style.display = 'none';
        chatInputArea.style.display = 'flex';
        adjustChatMessagesPadding();
      }
    }

    function handleComprovante(extractedText) {
      const normalizedText = extractedText.toLowerCase()
        .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
        .replace(/[^a-z0-9\s.,]/g, "");

      // Lista de valores válidos
      const validValuesMap = new Map([
        [10, 5], [20, 10], [30, 15], [40, 20], [50, 25], [60, 30], [70, 35], [80, 40],
        [90, 45], [100, 50], [110, 55], [120, 60], [130, 65], [140, 70], [150, 75],
        [160, 80], [170, 85], [180, 90], [190, 95], [200, 100]
      ]);

      // Nomes autorizados
      const nameKeywords = ['antonio', 'renimar', 'pinheiro', 'almeida'];

      // Extrai valores do texto
      const amountPattern = /(?:r\$\s*|rs\s*)?(\d{1,3}(?:[.,]\d{2})?)/g;
      let extractedAmounts = [];
      let match;
      while ((match = amountPattern.exec(normalizedText)) !== null) {
        const amountStr = match[1].replace(',', '.');
        const amountFloat = parseFloat(amountStr);
        if (!isNaN(amountFloat)) {
          extractedAmounts.push(amountFloat);
        }
      }

      // Tenta encontrar valor válido
      let matchedValue = null;
      for (const amt of extractedAmounts) {
        // Arredondar para inteiro para checar mapa
        const rounded = Math.round(amt);
        if (validValuesMap.has(rounded)) {
          matchedValue = rounded;
          break;
        }
      }

      // Checa nomes no texto
      const hasValidName = nameKeywords.some(n => normalizedText.includes(n));

      if (matchedValue !== null && hasValidName) {
        expectedPaymentAmount = matchedValue;
        addMessage("Pix confirmado, amor 😘... Aqui estão suas fotos 😈", 'suellen');
        sendPhotosWithDelay(matchedValue);
        ocrStatusMessage.textContent = 'Pagamento validado com sucesso!';
      } else {
        const errorMessage = "Hmm... parece que algo não tá certo aqui, viu? 💋 Confere o comprovante pra mim, amor?";
        addMessage(errorMessage, 'suellen');
        ocrStatusMessage.textContent = 'Validação falhou. Por favor, tente novamente.';
        addCustomActionButton('Ver Fotos / Enviar Comprovante', () => {
          chatInputArea.style.display = 'none';
          pixUploadArea.style.display = 'flex';
          waitingForComprovante = true;
          adjustChatMessagesPadding();
          initializeTesseractWorker();
        });
      }
    }

    async function sendPhotosWithDelay(amountPaid) {
      const numPhotos = (amountPaid / 10) * 5;
      const photosToSendThisBatch = Math.min(numPhotos, 100 - photosSentCount);

      if (photosToSendThisBatch > 0) {
        for (let i = 0; i < photosToSendThisBatch; i++) {
          photosSentCount++;
          const imageUrl = `foto${photosSentCount}.webp`;

          addTypingIndicator();
          await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));
          removeTypingIndicator();

          addMessage('', 'suellen', true, imageUrl);

          if (i < photosToSendThisBatch - 1) {
            await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 1000));
          }
        }

        if (photosSentCount >= 100) {
          addTypingIndicator();
          await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 1000));
          removeTypingIndicator();
          addMessage("Acabou por hoje, meu bem. Mas fica por perto... logo logo eu volto com mais surpresas 🔥", 'suellen');
        }
      } else {
        if (photosSentCount >= 100) {
          addTypingIndicator();
          await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 1000));
          removeTypingIndicator();
          addMessage("Já te enviei todas as fotos que tinha por agora, amor. Mas logo logo tem mais! 😉", 'suellen');
        } else {
          addTypingIndicator();
          await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 1000));
          removeTypingIndicator();
          addMessage("Não consigo enviar essa quantidade de fotos agora, amor. Tenta um valor diferente? 💋", 'suellen');
        }
      }
    }

    sendButton.addEventListener('click', () => {
      const message = chatInput.value.trim();
      if (message) {
        chatInput.value = '';
        processUserMessage(message);
      }
    });

    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        sendButton.click();
      }
    });

    // Botões upload
    uploadPhotoButton.addEventListener('click', () => {
      receiptFileInput.accept = 'image/*';
      receiptFileInput.click();
    });

    uploadPdfButton.addEventListener('click', () => {
      receiptFileInput.accept =
receiptFileInput.accept = 'application/pdf';
      receiptFileInput.click();
    });

    attachButton.addEventListener('click', () => {
      // Abre a área de envio de comprovante
      pixUploadArea.style.display = 'flex';
      chatInputArea.style.display = 'none';
      adjustChatMessagesPadding();
      waitingForComprovante = true;
      initializeTesseractWorker();
    });

    sendPhotoButton.addEventListener('click', () => {
      // Atalho para enviar foto de comprovante
      receiptFileInput.accept = 'image/*';
      receiptFileInput.click();
    });

    window.addEventListener('resize', () => {
      adjustChatContainerHeight();
    });

    // Inicialização
    adjustChatContainerHeight();

    // Mensagem inicial da Suellen
    addMessage("Oiê, meu bem. Que bom te ver por aqui... 🙈suellen');

  </script>
</body>
</html>
