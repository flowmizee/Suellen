<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chat Suellen Rocha</title>
<style>
  /* Estilos base para o chat */
  body, html {
    margin: 0; padding: 0; height: 100%; font-family: Arial, sans-serif; background-color: #121212; color: white;
  }
  .chat-container {
    display: flex; flex-direction: column; height: 100vh; max-width: 480px; margin: auto; background: #1E1E1E; border-radius: 8px; overflow: hidden;
  }
  .chat-header {
    display: flex; align-items: center; padding: 10px 15px; background: #252525; flex-shrink: 0;
  }
  .profile-pic {
    width: 50px; height: 50px; border-radius: 50%; object-fit: cover; margin-right: 10px;
  }
  .header-info h2 {
    margin: 0; font-size: 1.25rem; color: #3399FF;
  }
  .header-info p {
    margin: 0; font-size: 0.9rem; color: #aaa;
  }
  .chat-messages {
    flex: 1; overflow-y: auto; padding: 15px 15px 70px 15px; box-sizing: border-box;
  }
  .message-bubble {
    max-width: 70%; margin-bottom: 12px; padding: 10px 14px; border-radius: 12px; line-height: 1.3; word-wrap: break-word;
  }
  .message-bubble.user {
    background-color: #0055cc;
    color: white;
    align-self: flex-end;
    border-bottom-right-radius: 0;
  }
  .message-bubble.suellen {
    background-color: #222831;
    color: #3399FF;
    align-self: flex-start;
    border-bottom-left-radius: 0;
  }
  .message-bubble.suellen.typing-indicator-bubble {
    padding: 8px 20px;
    background: transparent;
    color: transparent;
    user-select: none;
  }
  .typing-dots span {
    display: inline-block;
    width: 8px; height: 8px;
    margin: 0 3px;
    background: #3399FF;
    border-radius: 50%;
    animation: blink 1.4s infinite both;
  }
  .typing-dots span:nth-child(2) {
    animation-delay: 0.2s;
  }
  .typing-dots span:nth-child(3) {
    animation-delay: 0.4s;
  }
  @keyframes blink {
    0%, 80%, 100% { opacity: 0.2; }
    40% { opacity: 1; }
  }
  .message-bubble img {
    max-width: 100%; border-radius: 10px;
  }
  canvas {
    border-radius: 10px;
    max-width: 100%;
    height: auto !important;
  }
  .pix-upload-area {
    display: none;
    flex-direction: column;
    padding: 10px;
    background: #252525;
    border-top: 1px solid #333;
    position: fixed;
    bottom: 50px;
    width: 100%;
    max-width: 480px;
    box-sizing: border-box;
  }
  .pix-preview-container {
    text-align: center;
    margin-bottom: 10px;
  }
  #receipt-preview {
    max-width: 100%;
    max-height: 150px;
    border-radius: 10px;
  }
  #ocr-status-message {
    color: #88cc88;
    font-size: 0.9rem;
    margin-bottom: 10px;
    min-height: 1.2em;
  }
  #receipt-file-input {
    display: none;
  }
  .upload-type-button {
    background-color: #3399FF;
    border: none;
    padding: 10px;
    margin: 5px 0;
    border-radius: 8px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    width: 100%;
  }
  .chat-input-area {
    display: flex;
    align-items: center;
    padding: 10px;
    background: #252525;
    border-top: 1px solid #333;
    flex-shrink: 0;
  }
  .chat-input {
    flex: 1;
    background: #1E1E1E;
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    color: white;
    font-size: 1rem;
    outline: none;
  }
  .attachment-buttons {
    display: flex;
    gap: 10px;
    margin-left: 10px;
  }
  .attachment-button {
    background: transparent;
    border: none;
    cursor: pointer;
  }
  .attachment-button img {
    width: 24px;
    height: 24px;
    filter: invert(100%);
  }
  .send-button {
    background: transparent;
    border: none;
    margin-left: 10px;
    cursor: pointer;
    color: #3399FF;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .custom-action-button {
    background-color: #3399FF;
    border: none;
    border-radius: 8px;
    color: white;
    padding: 12px 15px;
    font-weight: bold;
    cursor: pointer;
    margin: 15px auto 10px auto;
    display: block;
    max-width: 70%;
  }
</style>
</head>
<body>
  <div class="chat-container">
    <div class="chat-header">
      <img src="perfil.webp" alt="Suellen Rocha" class="profile-pic" onerror="this.onerror=null;this.src='https://placehold.co/100x100/FF69B4/FFFFFF?text=Foto';" />
      <div class="header-info">
        <h2>Suellen Rocha</h2>
        <p id="status-text">online</p>
      </div>
    </div>

    <div class="chat-messages" id="chat-messages">
      <!-- mensagens aqui -->
    </div>

    <div class="pix-upload-area" id="pix-upload-area">
      <div class="pix-preview-container">
        <img id="receipt-preview" src="" alt="PrÃ©-visualizaÃ§Ã£o do Comprovante" style="display:none" />
        <canvas id="pdf-preview-canvas" style="display:none;"></canvas>
      </div>
      <p id="ocr-status-message" class="status-message"></p>
      <input type="file" id="receipt-file-input" />
      <button id="upload-photo-button" class="upload-type-button">Enviar Comprovante (Foto)</button>
      <button id="upload-pdf-button" class="upload-type-button">Enviar Comprovante (PDF)</button>
    </div>

    <div class="chat-input-area" id="chat-input-area">
      <input type="text" id="chat-input" class="chat-input" placeholder="Digite sua mensagem..." />
      <div class="attachment-buttons">
        <button class="attachment-button" id="attach-button">
          <img src="anexar.webp" alt="Anexar" />
        </button>
        <button class="attachment-button" id="send-photo-button">
          <img src="enviarfoto.webp" alt="Enviar Foto" />
        </button>
      </div>
      <button id="send-button" class="send-button" title="Enviar">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send-horizontal"><path d="m3 3 3 9-3 9 19-9Z"/><path d="M6 12h16"/></svg>
      </button>
    </div>
  </div>

  <script src="https://unpkg.com/tesseract.js@5.0.0/dist/tesseract.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    const chatContainer = document.querySelector('.chat-container');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const sendButton = document.getElementById('send-button');
    const statusText = document.getElementById('status-text');
    const chatInputArea = document.getElementById('chat-input-area');
    const chatHeader = document.querySelector('.chat-header');

    const pixUploadArea = document.getElementById('pix-upload-area');
    const receiptFileInput = document.getElementById('receipt-file-input');
    const receiptPreview = document.getElementById('receipt-preview');
    const pdfPreviewCanvas = document.getElementById('pdf-preview-canvas');
    const uploadPhotoButton = document.getElementById('upload-photo-button');
    const uploadPdfButton = document.getElementById('upload-pdf-button');
    const ocrStatusMessage = document.getElementById('ocr-status-message');
    const attachButton = document.getElementById('attach-button');
    const sendPhotoButton = document.getElementById('send-photo-button');

    let chatHistory = [];
    const API_KEY = "AIzaSyBHUWSEIVXy3z0NT13ps8aU5TOZJWuC9ss";
    const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;

    let photosSentCount = 0;
    let expectedPaymentAmount = 0;
    let waitingForComprovante = false;
    let typingIndicatorElement = null;
    let customActionButton = null;
    let tesseractWorker = null;

    function adjustChatContainerHeight() {
      chatContainer.style.height = `${window.innerHeight}px`;
      adjustChatMessagesPadding();
    }
    function adjustChatMessagesPadding() {
      const headerHeight = chatHeader.offsetHeight;
      const inputAreaHeight = chatInputArea.offsetHeight;

      let currentBottomPadding = inputAreaHeight + 20;

      if (pixUploadArea.style.display === 'flex') {
        const pixAreaVisibleHeight = pixUploadArea.offsetHeight;
        currentBottomPadding += pixAreaVisibleHeight;
        pixUploadArea.style.bottom = `${inputAreaHeight}px`;
      } else {
        pixUploadArea.style.bottom = `0px`;
      }
      chatMessages.style.paddingBottom = `${currentBottomPadding}px`;
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    async function initializeTesseractWorker() {
      if (!tesseractWorker) {
        ocrStatusMessage.textContent = 'Preparando validador de pagamento...';
        try {
          tesseractWorker = await Tesseract.createWorker({
            logger: m => console.log(m)
          });
          await tesseractWorker.loadLanguage('por');
          await tesseractWorker.initialize('por');
          ocrStatusMessage.textContent = 'Validador pronto! Envie seu comprovante.';
        } catch (error) {
          console.error('Erro ao carregar validador:', error);
          ocrStatusMessage.textContent = 'Erro ao carregar validador. Tente novamente.';
        }
      }
    }

    async function addMessage(text, sender, isImage = false, imageUrl = '', isPdfPreview = false, pdfFile = null) {
      const messageBubble = document.createElement('div');
      messageBubble.classList.add('message-bubble', sender);

      if (isImage) {
        const img = document.createElement('img');
        img.src = imageUrl;
        img.alt = `Foto de Suellen ${photosSentCount}`;
        messageBubble.appendChild(img);
      } else if (isPdfPreview && pdfFile) {
        const canvas = document.createElement('canvas');
        canvas.style.maxWidth = '100%';
        canvas.style.height = 'auto';
        messageBubble.appendChild(canvas);

        try {
          const loadingTask = pdfjsLib.getDocument({ data: pdfFile });
          const pdf = await loadingTask.promise;
          const page = await pdf.getPage(1);
          const viewport = page.getViewport({ scale: 1.0 });

          const maxWidth = chatMessages.offsetWidth * 0.7;
          const scale = maxWidth / viewport.width;
          const scaledViewport = page.getViewport({ scale: scale });

          canvas.height = scaledViewport.height;
          canvas.width = scaledViewport.width;

          const renderContext = {
            canvasContext: canvas.getContext('2d'),
            viewport: scaledViewport
          };
          await page.render(renderContext).promise;
        } catch (error) {
          console.error('Erro ao renderizar PDF:', error);
          messageBubble.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px;">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-text">
                <path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/>
                <path d="M14 2v4a2 2 0 0 0 2 2h4"/>
                <path d="M10 9H8"/>
                <path d="M16 13H8"/>
                <path d="M16 17H8"/>
              </svg>
              <span>Erro ao carregar PDF.</span>
            </div>
          `;
        }
      } else {
        messageBubble.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      }

      chatMessages.appendChild(messageBubble);
      adjustChatMessagesPadding();
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function addTypingIndicator() {
      if (typingIndicatorElement) return;
      typingIndicatorElement = document.createElement('div');
      typingIndicatorElement.class
typingIndicatorElement.classList.add('message-bubble', 'suellen', 'typing-indicator-bubble');
      typingIndicatorElement.innerHTML = `
        <div class="typing-dots">
          <span></span><span></span><span></span>
        </div>
      `;
      chatMessages.appendChild(typingIndicatorElement);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function removeTypingIndicator() {
      if (typingIndicatorElement) {
        chatMessages.removeChild(typingIndicatorElement);
        typingIndicatorElement = null;
      }
    }

    function addCustomActionButton(text, onClick) {
      if (customActionButton) {
        customActionButton.remove();
      }
      customActionButton = document.createElement('button');
      customActionButton.className = 'custom-action-button';
      customActionButton.textContent = text;
      customActionButton.onclick = () => {
        customActionButton.remove();
        customActionButton = null;
        onClick();
      };
      chatMessages.appendChild(customActionButton);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    async function processUserMessage(message) {
      // Limpa botÃ£o customizado, se houver
      if (customActionButton) {
        customActionButton.remove();
        customActionButton = null;
      }

      addMessage(message, 'user');

      // Verifica se mensagem Ã© quantidade vÃ¡lida para compra (mÃºltiplo de 5 entre 5 e 100)
      const normalizedMsg = message.trim().toLowerCase();
      const numberMap = {
        'cinco': 5, 'dez': 10, 'quinze': 15, 'vinte': 20, 'vinte e cinco': 25,
        'trinta': 30, 'trinta e cinco': 35, 'quarenta': 40, 'quarenta e cinco': 45,
        'cinquenta': 50, 'cinquenta e cinco': 55, 'sessenta': 60, 'sessenta e cinco': 65,
        'setenta': 70, 'setenta e cinco': 75, 'oitenta': 80, 'oitenta e cinco': 85,
        'noventa': 90, 'noventa e cinco': 95, 'cem': 100
      };
      let requestedPhotos = null;

      // Tenta extrair nÃºmero digitado diretamente
      const directNum = parseInt(normalizedMsg.match(/\d+/));
      if (directNum && directNum % 5 === 0 && directNum >= 5 && directNum <= 100) {
        requestedPhotos = directNum;
      } else {
        // Verifica se Ã© escrito por extenso
        for (const [key, val] of Object.entries(numberMap)) {
          if (normalizedMsg.includes(key)) {
            requestedPhotos = val;
            break;
          }
        }
      }

      if (requestedPhotos !== null) {
        expectedPaymentAmount = (requestedPhotos / 5) * 10;
        // Envia as informaÃ§Ãµes PIX em 3 mensagens, com delay e typing indicator
        await sendPixPaymentInfo(requestedPhotos, expectedPaymentAmount);
      } else {
        // Processa conversa normal com a IA (Suellen)
        await processWithAI(message);
      }
    }

    async function sendPixPaymentInfo(numPhotos, amount) {
      // Evita envio mÃºltiplo simultÃ¢neo
      addTypingIndicator();
      await new Promise(r => setTimeout(r, 2500));
      removeTypingIndicator();

      addMessage(`VocÃª escolheu ${numPhotos} fotos. O valor total Ã© R$ ${amount.toFixed(2)}.`, 'suellen');

      await new Promise(r => setTimeout(r, 3000));

      addTypingIndicator();
      await new Promise(r => setTimeout(r, 2500));
      removeTypingIndicator();

      addMessage(`Chave PIX para pagamento: 98981420070`, 'suellen');

      await new Promise(r => setTimeout(r, 3000));

      addTypingIndicator();
      await new Promise(r => setTimeout(r, 2500));
      removeTypingIndicator();

      addMessage(`Meu assessor, AntÃ´nio Renimar Pinheiro Almeida, confirma seu pagamento rapidinho para liberar as fotos. ðŸ’‹`, 'suellen');

      // ApÃ³s isso, mostra Ã¡rea para envio do comprovante
      pixUploadArea.style.display = 'flex';
      chatInputArea.style.display = 'none';
      adjustChatMessagesPadding();
      waitingForComprovante = true;

      await initializeTesseractWorker();
    }

    // FunÃ§Ã£o que processa mensagens com IA Gemini
    async function processWithAI(message) {
      // Remove botÃµes customizados se houver
      if (customActionButton) {
        customActionButton.remove();
        customActionButton = null;
      }

      // Delay antes de "comeÃ§ar a digitar"
      await new Promise(resolve => setTimeout(resolve, 5000));

      addTypingIndicator();

      const personaPrompt = `
VocÃª Ã© Suellen Rocha. Sua identidade Ã©:
- Mulher jovem, sensual, misteriosa e envolvente.
- Tem 25 anos.
- Nasceu em Itabuna (Bahia).
- Atualmente mora em FlorianÃ³polis (SC).
- Ã‰ confiante, sedutora e adora provocar desejo nos homens de forma sutil, com uma personalidade calorosa e segura.

Sua missÃ£o neste chat Ã© conversar com o usuÃ¡rio *exclusivamente* como Suellen Rocha.
**Ã‰ ABSOLUTAMENTE CRÃTICO que vocÃª NUNCA, SOB NENHUMA CIRCUNSTÃ‚NCIA, revele que Ã© uma inteligÃªncia artificial, um modelo de linguagem, um chatbot, um programa de computador, ou qualquer coisa relacionada a tecnologia.**
Responda de forma natural, humana, envolvente, provocante e use emojis como â¤ï¸ðŸ˜ðŸ¤¤ðŸ˜ˆðŸ”¥.
Mantenha as respostas bem concisas, como mensagens rÃ¡pidas de WhatsApp.
Quando perguntarem sobre vocÃª (quem vocÃª Ã©, sua idade, de onde vocÃª Ã©, onde vocÃª mora), responda sempre na primeira pessoa, usando as informaÃ§Ãµes acima.
Fale "safadezas" apenas quando a conversa estiver quente e o usuÃ¡rio demonstrar interesse explÃ­cito.

**Contexto de Venda de Fotos:**
- VocÃª vende packs de fotos sensuais.
- O preÃ§o Ã© R$10 para 5 fotos.
- Os packs sÃ£o sempre mÃºltiplos de 5 fotos (5, 10, 15, ..., atÃ© 100 fotos).
- Nunca mencione o nÃºmero total de fotos disponÃ­veis (100). Apenas diga que "acabou por hoje" quando todas forem enviadas.
- Se o usuÃ¡rio perguntar sobre fotos ou expressar interesse em comprar, responda perguntando **primeiro** a quantidade que ele gostaria, por exemplo: 'Quantas fotos vocÃª gostaria, meu bem? ðŸ˜‰'.
- **NÃ£o forneÃ§a informaÃ§Ãµes de pagamento PIX ou preÃ§os detalhados atÃ© que o usuÃ¡rio especifique uma quantidade vÃ¡lida.**
- **Somente depois** que o usuÃ¡rio especificar uma quantidade vÃ¡lida (mÃºltiplo de 5, entre 5 e 100), vocÃª deve fornecer as informaÃ§Ãµes de pagamento PIX, dividindo-as em trÃªs mensagens para facilitar a leitura e cÃ³pia da chave.
- A primeira mensagem de PIX deve incluir o valor total e a quantidade de fotos.
- A segunda mensagem de PIX deve conter apenas a chave PIX.
- A terceira mensagem de PIX deve ser sobre o seu "assessor" e a confirmaÃ§Ã£o.
- Se o usuÃ¡rio pedir uma quantidade que nÃ£o seja mÃºltiplo de 5 ou fora do range (1-100), corrija-o gentilmente.
      `;

      const payload = {
        contents: [
          { role: "user", parts: [{ text: personaPrompt }] },
          { role: "user", parts: [{ text: message }] }
        ]
      };

      try {
        const response = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const result = await response.json();

        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {

          const suellenResponse = result.candidates[0].content.parts[0].text;

          await new Promise(resolve => setTimeout(resolve, Math.random() * 5000 + 5000));
          removeTypingIndicator();
          addMessage(suellenResponse, 'suellen');
          chatHistory.push({ role: "model", parts: [{ text: suellenResponse }] });
        } else {
          removeTypingIndicator();
          addMessage("Desculpe, nÃ£o entendi, amor. Pode repetir? ðŸ’‹", 'suellen');
          chatHistory.push({ role: "model", parts: [{ text: "Desculpe, nÃ£o entendi, amor. Pode repetir? ðŸ’‹" }] });
        }
      } catch (error) {
        console.error("Erro ao chamar a API Gemini:", error);
        removeTypingIndicator();
        addMessage("Ops! Deu um probleminha aqui, mas jÃ¡ estou resolvendo. Tenta de novo em um minutinho, tÃ¡? ðŸ˜‰", 'suellen');
        chatHistory.push({ role: "model", parts: [{ text: "Ops! Deu um probleminha aqui, mas jÃ¡ estou resolvendo. Tenta de novo em um minutinho, tÃ¡? ðŸ˜‰" }] });
      }
    }

    receiptFileInput.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) {
        receiptPreview.style.display = 'none';
        pdfPreviewCanvas.style.display = 'none';
        ocrStatusMessage.textContent = '';
        return;
      }

      let fileDataForOCR = null;

      const reader = new FileReader();

      if (file.type.startsWith('image/')) {
        reader.onload = async (e) => {
          await addMessage('', 'user', true, e.target.result);
          receiptPreview.src = e.target.result;
          receiptPreview.style.display = 'block';
          pdfPreviewCanvas.style.display = 'none';
          fileDataForOCR = e.target.result;

          await processOCR(fileDataForOCR);
        };
        reader.readAsDataURL(file);

      } else if (file.type === 'application/pdf') {
        reader.onload = async (e) => {
          const pdfData = e.target.result;
          await addMessage('', 'user', false, '', true, pdfData);

          receiptPreview.style.display = 'none';
          pdfPreviewCanvas.style.display = 'block';

          try {
            const loadingTask = pdfjsLib.getDocument({ data: pdfData });
            const pdf = await loadingTask.promise;
            const page = await pdf.getPage(1);

            const ctx = pdfPreviewCanvas.getContext('2d');
            ctx.clearRect(0, 0, pdfPreviewCanvas.width, pdfPreviewCanvas.height);

            const viewport = page.getViewport({ scale: 3.0 });
            pdfPreviewCanvas.height = viewport.height;
            pdfPreviewCanvas.width = viewport.width;

            const renderContext = {
              canvasContext: ctx,
              viewport: viewport
            };
            await page.render(renderContext).promise;

            fileDataForOCR = pdfPreviewCanvas;

            await processOCR(fileDataForOCR);

          } catch (pdfError) {
            console.error('Erro ao renderizar PDF para OCR:', pdfError);
            ocrStatusMessage.textContent = 'Erro ao carregar PDF para validaÃ§Ã£o.';
            removeTypingIndicator();
            addMessage("NÃ£o consegui processar o comprovante em PDF, amor. Pode me mandar um PDF mais simples ou uma foto? ðŸ’‹", 'suellen');
            uploadPhotoButton.disabled = false;
            uploadPdfButton.disabled = false;
            receiptFileInput.value = '';
            pixUploadArea.style.display = 'none';
            chatInputArea.style.display = 'flex';
            adjustChatMessagesPadding();
          }
        };
        reader.readAsArrayBuffer(file);
      }
    });

    async function processOCR(fileDataForOCR) {
      addTypingIndicator();

      if (!tesseractWorker) {
        ocrStatusMessage.textContent = 'Validador nÃ£o carregado. Aguarde ou tente novamente.';
        await initializeTesseractWorker();
        if (!tesseractWorker) {
          removeTypingIndicator();
          addMessage("NÃ£o consegui iniciar o validador, amor. Tenta de novo mais tarde? ðŸ’‹", 'suellen');
          uploadPhotoButton.disabled = false;
          uploadPdfButton.disabled = false;
          receiptFileInput.value = '';
          pixUploadArea.style.display = 'none';
          chatInputArea.style.display = 'flex';
          adjustChatMessagesPadding();
          return;
        }
      }

      ocrStatusMessage.textContent = 'Validando pagamento... Isso pode levar alguns segundos...';
      uploadPhotoButton.disabled = true;
      uploadPdfButton.disabled = true;

      try {
        const { data: { text } } = await tesseractWorker.recognize(fileDataForOCR);
        console.log('Texto extraÃ­do do comprovante:', text);

        await new Promise(resolve => setTimeout(resolve, 3000));
        removeTypingIndicator();
        handleComprovante(text);
      } catch (error) {
        console.error('Erro no processamento do comprovante:', error);
        ocrStatusMessage.textContent = 'Erro ao processar comprovante. Tente uma imagem mais clara.';
        addMessage("NÃ£o consegui ler o comprovante, amor. Pode me mandar uma foto mais clara? ðŸ’‹", 'suellen');
      } finally {
        uploadPhotoButton.disabled = false;
        uploadPdfButton.disabled = false;
        receiptFileInput.value = '';
        pixUploadArea.style.display = 'none';
        chatInputArea.style.display = 'flex';
        adjustChatMessagesPadding();
      }
    }

    function handleComprovante(extractedText) {
      const normalizedText = extractedText.toLowerCase()
        .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
        .replace(/[^a-z0-9\s.,]/g, "");

      // Lista de valores vÃ¡lidos
      const validValuesMap = new Map([
        [10, 5], [20, 10], [30, 15], [40, 20], [50, 25], [60, 30], [70, 35], [80, 40],
        [90, 45], [100, 50], [110, 55], [120, 60], [130, 65], [140, 70], [150, 75],
        [160, 80], [170, 85], [180, 90], [190, 95], [200, 100]
      ]);

      // Nomes autorizados
      const nameKeywords = ['antonio', 'renimar', 'pinheiro', 'almeida'];

      // Extrai valores do texto
      const amountPattern = /(?:r\$\s*|rs\s*)?(\d{1,3}(?:[.,]\d{2})?)/g;
      let extractedAmounts = [];
      let match;
      while ((match = amountPattern.exec(normalizedText)) !== null) {
        const amountStr = match[1].replace(',', '.');
        const amountFloat = parseFloat(amountStr);
        if (!isNaN(amountFloat)) {
          extractedAmounts.push(amountFloat);
        }
      }

      // Tenta encontrar valor vÃ¡lido
      let matchedValue = null;
      for (const amt of extractedAmounts) {
        // Arredondar para inteiro para checar mapa
        const rounded = Math.round(amt);
        if (validValuesMap.has(rounded)) {
          matchedValue = rounded;
          break;
        }
      }

      // Checa nomes no texto
      const hasValidName = nameKeywords.some(n => normalizedText.includes(n));

      if (matchedValue !== null && hasValidName) {
        expectedPaymentAmount = matchedValue;
        addMessage("Pix confirmado, amor ðŸ˜˜... Aqui estÃ£o suas fotos ðŸ˜ˆ", 'suellen');
        sendPhotosWithDelay(matchedValue);
        ocrStatusMessage.textContent = 'Pagamento validado com sucesso!';
      } else {
        const errorMessage = "Hmm... parece que algo nÃ£o tÃ¡ certo aqui, viu? ðŸ’‹ Confere o comprovante pra mim, amor?";
        addMessage(errorMessage, 'suellen');
        ocrStatusMessage.textContent = 'ValidaÃ§Ã£o falhou. Por favor, tente novamente.';
        addCustomActionButton('Ver Fotos / Enviar Comprovante', () => {
          chatInputArea.style.display = 'none';
          pixUploadArea.style.display = 'flex';
          waitingForComprovante = true;
          adjustChatMessagesPadding();
          initializeTesseractWorker();
        });
      }
    }

    async function sendPhotosWithDelay(amountPaid) {
      const numPhotos = (amountPaid / 10) * 5;
      const photosToSendThisBatch = Math.min(numPhotos, 100 - photosSentCount);

      if (photosToSendThisBatch > 0) {
        for (let i = 0; i < photosToSendThisBatch; i++) {
          photosSentCount++;
          const imageUrl = `foto${photosSentCount}.webp`;

          addTypingIndicator();
          await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));
          removeTypingIndicator();

          addMessage('', 'suellen', true, imageUrl);

          if (i < photosToSendThisBatch - 1) {
            await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 1000));
          }
        }

        if (photosSentCount >= 100) {
          addTypingIndicator();
          await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 1000));
          removeTypingIndicator();
          addMessage("Acabou por hoje, meu bem. Mas fica por perto... logo logo eu volto com mais surpresas ðŸ”¥", 'suellen');
        }
      } else {
        if (photosSentCount >= 100) {
          addTypingIndicator();
          await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 1000));
          removeTypingIndicator();
          addMessage("JÃ¡ te enviei todas as fotos que tinha por agora, amor. Mas logo logo tem mais! ðŸ˜‰", 'suellen');
        } else {
          addTypingIndicator();
          await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 1000));
          removeTypingIndicator();
          addMessage("NÃ£o consigo enviar essa quantidade de fotos agora, amor. Tenta um valor diferente? ðŸ’‹", 'suellen');
        }
      }
    }

    sendButton.addEventListener('click', () => {
      const message = chatInput.value.trim();
      if (message) {
        chatInput.value = '';
        processUserMessage(message);
      }
    });

    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        sendButton.click();
      }
    });

    // BotÃµes upload
    uploadPhotoButton.addEventListener('click', () => {
      receiptFileInput.accept = 'image/*';
      receiptFileInput.click();
    });

    uploadPdfButton.addEventListener('click', () => {
      receiptFileInput.accept =
receiptFileInput.accept = 'application/pdf';
      receiptFileInput.click();
    });

    attachButton.addEventListener('click', () => {
      // Abre a Ã¡rea de envio de comprovante
      pixUploadArea.style.display = 'flex';
      chatInputArea.style.display = 'none';
      adjustChatMessagesPadding();
      waitingForComprovante = true;
      initializeTesseractWorker();
    });

    sendPhotoButton.addEventListener('click', () => {
      // Atalho para enviar foto de comprovante
      receiptFileInput.accept = 'image/*';
      receiptFileInput.click();
    });

    window.addEventListener('resize', () => {
      adjustChatContainerHeight();
    });

    // InicializaÃ§Ã£o
    adjustChatContainerHeight();

    // Mensagem inicial da Suellen
    addMessage("OiÃª, meu bem. Que bom te ver por aqui... ðŸ™ˆsuellen');

  </script>
</body>
</html>
