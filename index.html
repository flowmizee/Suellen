<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Suellen Rocha - Chat</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Define as variáveis de cores e fontes para fácil manutenção */
        :root {
            --bg-dark: #28004D; /* Um roxo bem escuro */
            --bg-medium: #4A0080; /* Um roxo médio para o chat */
            --accent-pink: #FF69B4; /* Rosa vibrante */
            --accent-red: #FF007F; /* Vermelho vibrante */
            --text-light: #F0F0F0;
            --text-dark: #333333;
            --bubble-user: #FF69B4; /* Cor da bolha do usuário */
            --bubble-suellen: #FFFFFF; /* Cor da bolha da Suellen */
        }

        /* Aplica box-sizing para um modelo de caixa mais previsível */
        * {
            box-sizing: border-box;
        }

        /* Estilos globais para o corpo da página */
        html, body {
            height: 100%; /* Garante que HTML e Body ocupem a altura total da viewport */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Evita que o body tenha scroll próprio */
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Contêiner principal do chat - agora ocupa 100% da altura da viewport e é um flex container */
        .chat-container {
            width: 100%;
            max-width: 450px; /* Largura máxima para simular um celular */
            height: 100vh; /* Ocupa a altura total da viewport */
            position: relative; /* Necessário para posicionamento absoluto da pix-upload-area */
            background-color: var(--bg-medium);
            border-radius: 25px; /* Bordas arredondadas para o contêiner principal */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column; /* Organiza os filhos em coluna */
            overflow: hidden; /* Importante para que o conteúdo não vaze das bordas arredondadas */
        }

        /* Cabeçalho do chat - não encolhe */
        .chat-header {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            background: linear-gradient(90deg, var(--accent-red) 0%, var(--accent-pink) 100%);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 10; /* Garante que fique acima de outros elementos */
            flex-shrink: 0; /* Impede que o cabeçalho encolha */
        }

        /* Imagem de perfil no cabeçalho */
        .profile-pic {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--text-light);
            margin-right: 15px;
        }

        /* Informações do cabeçalho (nome e status) */
        .header-info h2 {
            margin: 0;
            font-size: 1.2em;
            color: var(--text-light);
            font-weight: 600;
        }

        .header-info p {
            margin: 0;
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Área de exibição das mensagens - ocupa o espaço restante e é scrollable */
        .chat-messages {
            flex-grow: 1; /* Permite que ocupe o espaço restante */
            padding: 20px; /* Padding padrão para todos os lados */
            overflow-y: auto; /* Adiciona scroll se as mensagens excederem a altura */
            display: flex;
            flex-direction: column;
            gap: 10px;
            scroll-behavior: smooth; /* Rolagem suave */
            /* padding-bottom será ajustado via JS */
        }

        /* Bolhas de mensagem */
        .message-bubble {
            max-width: 80%;
            padding: 12px 18px;
            border-radius: 20px;
            word-wrap: break-word;
            line-height: 1.4;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .message-bubble.user {
            background-color: var(--bubble-user);
            color: var(--text-light);
            align-self: flex-end; /* Alinha a direita para mensagens do usuário */
            border-bottom-right-radius: 5px; /* Detalhe no canto da bolha */
        }

        .message-bubble.suellen {
            background-color: var(--bubble-suellen);
            color: var(--text-dark);
            align-self: flex-start; /* Alinha a esquerda para mensagens da Suellen */
            border-bottom-left-radius: 5px; /* Detalhe no canto da bolha */
        }

        .message-bubble img {
            max-width: 100%;
            border-radius: 15px;
            margin-top: 5px;
        }

        /* Estilo para o indicador de digitação (bolha com 3 pontos) */
        .message-bubble.typing-indicator-bubble {
            background-color: var(--bubble-suellen);
            color: var(--text-dark);
            align-self: flex-start;
            border-bottom-left-radius: 5px;
            padding: 10px 15px; /* Padding ligeiramente menor */
            display: flex;
            align-items: center;
            width: fit-content; /* Ajusta a largura ao conteúdo */
            opacity: 1; /* Always visible when added */
        }

        .typing-dots {
            display: flex;
            align-items: center;
        }

        .typing-dots span {
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: rgba(0, 0, 0, 0.5); /* Darker dots for light bubble */
            border-radius: 50%;
            margin: 0 2px;
            animation: bounce 1.4s infinite ease-in-out both; /* Animação de "bounce" */
        }

        /* Atrasos para a animação dos pontos */
        .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
        .typing-dots span:nth-child(2) { animation-delay: -0.16s; }
        .typing-dots span:nth-child(3) { animation-delay: 0s; }

        /* Keyframes para a animação de "bounce" */
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        /* Área de input do chat - não encolhe */
        .chat-input-area {
            display: flex;
            padding: 15px 20px;
            background-color: var(--bg-medium);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10; /* Garante que fique acima de outros elementos */
            flex-shrink: 0; /* Impede que a área de input encolha */
        }

        /* Campo de input de texto */
        .chat-input {
            flex-grow: 1; /* Ocupa o máximo de espaço possível */
            padding: 12px 18px;
            border: none;
            border-radius: 25px;
            background-color: rgba(255, 255, 255, 0.15);
            color: var(--text-light);
            font-size: 1em;
            outline: none;
            margin-right: 10px;
        }

        .chat-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        /* Botão de envio */
        .send-button {
            background-color: var(--accent-pink);
            color: var(--text-light);
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            cursor: pointer;
            transition: background-color 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .send-button:hover {
            background-color: var(--accent-red);
        }

        /* Estilos para a nova área de upload de PIX - posicionada absolutamente */
        .pix-upload-area {
            display: none; /* Escondido por padrão */
            flex-direction: column;
            align-items: center;
            padding: 15px 20px;
            background-color: var(--bg-medium);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            position: absolute; /* Posicionada absolutamente dentro do chat-container */
            left: 0;
            right: 0;
            width: 100%;
            z-index: 9; /* Abaixo do chat-input-area */
            gap: 10px;
            /* bottom será ajustado via JS */
        }

        .pix-preview-container {
            width: 100%;
            max-height: 150px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 10px;
        }

        #receipt-preview {
            max-width: 100%;
            max-height: 150px;
            border-radius: 8px;
            object-fit: contain;
        }
        #pdf-preview-canvas {
            max-width: 100%;
            max-height: 150px;
            border-radius: 8px;
            object-fit: contain;
        }


        /* Esconde o input de arquivo padrão */
        #receipt-file-input {
            display: none; 
        }

        /* Estilos para os botões de upload de comprovante (Foto/PDF) */
        .pix-upload-area .upload-type-button {
            width: 100%;
            border-radius: 25px;
            height: auto;
            padding: 10px 20px;
            background-color: var(--accent-pink);
            color: var(--text-light);
            border: none;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            margin-top: 5px;
        }

        .pix-upload-area .upload-type-button:hover {
            background-color: var(--accent-red);
            transform: translateY(-1px);
        }

        .status-message {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            margin-top: 5px;
        }

        /* Estilos para o botão personalizado de "Ver Fotos / Enviar Comprovante" */
        .custom-action-button {
            background: linear-gradient(90deg, var(--accent-red) 0%, var(--accent-pink) 100%);
            color: var(--text-light);
            border: none;
            border-radius: 25px;
            padding: 12px 20px;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            margin-top: 10px;
            align-self: center; /* Centraliza o botão */
            width: fit-content; /* Ajusta a largura ao conteúdo */
        }

        .custom-action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }

        /* Responsividade para telas menores (celulares) */
        @media (max-width: 600px) {
            .chat-container {
                height: 100vh; /* Ocupa a altura total da tela em celulares */
                border-radius: 0; /* Remove bordas arredondadas em tela cheia */
            }
            .chat-header {
                border-radius: 0; /* Remove bordas arredondadas no cabeçalho */
            }
            /* O padding-bottom das mensagens e a posição das áreas de input/upload
               serão ajustados dinamicamente via JS para lidar com o teclado virtual. */
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <!-- Imagem de perfil da Suellen. O onerror fornece uma imagem de placeholder caso a original não carregue. -->
            <img src="perfil.webp" alt="Suellen Rocha" class="profile-pic" onerror="this.onerror=null;this.src='https://placehold.co/100x100/FF69B4/FFFFFF?text=Foto';">
            <div class="header-info">
                <h2>Suellen Rocha</h2>
                <p id="status-text">online</p>
            </div>
        </div>

        <div class="chat-messages" id="chat-messages">
            <!-- As mensagens, o indicador de digitação e o botão personalizado serão adicionados aqui pelo JavaScript -->
        </div>

        <!-- Nova seção para upload de comprovante PIX -->
        <div class="pix-upload-area" id="pix-upload-area">
            <div class="pix-preview-container">
                <img id="receipt-preview" src="" alt="Pré-visualização do Comprovante" style="display: none;">
                <canvas id="pdf-preview-canvas" style="display: none;"></canvas> <!-- Canvas para pré-visualização de PDF -->
            </div>
            <p id="ocr-status-message" class="status-message"></p>
            <input type="file" id="receipt-file-input"> <!-- Input de arquivo oculto -->
            <button id="upload-photo-button" class="upload-type-button">
                Enviar Comprovante (Foto)
            </button>
            <button id="upload-pdf-button" class="upload-type-button">
                Enviar Comprovante (PDF)
            </button>
        </div>

        <div class="chat-input-area" id="chat-input-area">
            <input type="text" id="chat-input" class="chat-input" placeholder="Digite sua mensagem...">
            <button id="send-button" class="send-button">
                <!-- Ícone de envio (seta) em SVG -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send-horizontal"><path d="m3 3 3 9-3 9 19-9Z"/><path d="M6 12h16"/></svg>
            </button>
        </div>
    </div>

    <!-- Inclui as bibliotecas Tesseract.js e PDF.js para OCR e visualização de PDF -->
    <script src='https://unpkg.com/tesseract.js@5.0.0/dist/tesseract.min.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js'></script>
    <script>
        // Configura o worker do PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

        // Variáveis globais para os elementos do chat
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');
        const statusText = document.getElementById('status-text');
        const chatInputArea = document.getElementById('chat-input-area'); // Referência à área de input
        const chatHeader = document.querySelector('.chat-header'); // Referência ao cabeçalho (usando classe)

        // Novas variáveis para a área de upload de PIX
        const pixUploadArea = document.getElementById('pix-upload-area');
        const receiptFileInput = document.getElementById('receipt-file-input');
        const receiptPreview = document.getElementById('receipt-preview'); // Para imagens
        const pdfPreviewCanvas = document.getElementById('pdf-preview-canvas'); // Para PDFs
        const uploadPhotoButton = document.getElementById('upload-photo-button'); // Novo botão para foto
        const uploadPdfButton = document.getElementById('upload-pdf-button');   // Novo botão para PDF
        const ocrStatusMessage = document.getElementById('ocr-status-message');

        // Histórico do chat para a API Gemini
        let chatHistory = [];
        // CHAVE DA API: IMPORTANTE! Insira sua chave da API do Gemini aqui.
        // A chave fornecida anteriormente pelo usuário foi AIzaSyBHUWSEIVXy3z0NT13ps8aU5TOZJWuC9ss
        const API_KEY = "AIzaSyBHUWSEIVXy3z0NT13ps8aU5TOZJWuC9ss"; 
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;

        // Variáveis de estado do jogo/venda
        let photosSentCount = 0;
        let expectedPaymentAmount = 0;
        let waitingForComprovante = false;
        let typingIndicatorElement = null; // Para controlar a bolha de digitação
        let customActionButton = null; // Para controlar o botão personalizado

        // Tesseract.js worker
        let tesseractWorker = null;

        // Função para ajustar o padding inferior das mensagens e a posição da área de upload
        function adjustChatMessagesPadding() {
            const inputAreaHeight = chatInputArea.offsetHeight;
            const headerHeight = chatHeader.offsetHeight;
            const pixUploadAreaHeight = pixUploadArea.offsetHeight;
            
            let bottomPadding = inputAreaHeight + 20; // Padding padrão para a área de input

            if (pixUploadArea.style.display === 'flex') {
                bottomPadding += pixUploadAreaHeight; // Adiciona a altura da área de upload se visível
                // Posiciona pixUploadArea logo acima de chatInputArea
                pixUploadArea.style.bottom = `${inputAreaHeight}px`;
            } else {
                // Quando oculto, garante que não interfira no layout
                pixUploadArea.style.bottom = `0px`;
            }
            
            // Ajusta o padding inferior para que as mensagens não fiquem por baixo da área de input/upload
            chatMessages.style.paddingBottom = `${bottomPadding}px`;
            // Ajusta o padding superior para que as mensagens não fiquem por baixo do cabeçalho
            // O padding-top do CSS já é suficiente para o espaçamento inicial.
            chatMessages.scrollTop = chatMessages.scrollHeight; // Rola para o final após o ajuste
        }

        // Função para inicializar o worker do Tesseract.js
        async function initializeTesseractWorker() {
            if (!tesseractWorker) {
                ocrStatusMessage.textContent = 'Preparando validador de pagamento...';
                try {
                    tesseractWorker = await Tesseract.createWorker('por'); // 'por' para português
                    ocrStatusMessage.textContent = 'Validador pronto! Envie seu comprovante.';
                } catch (error) {
                    console.error('Erro ao carregar validador:', error);
                    ocrStatusMessage.textContent = 'Erro ao carregar validador. Tente novamente.';
                }
            }
        }

        // Função para adicionar mensagem ao chat
        async function addMessage(text, sender, isImage = false, imageUrl = '', isPdfPreview = false, pdfFile = null) {
            const messageBubble = document.createElement('div');
            messageBubble.classList.add('message-bubble', sender);

            if (isImage) {
                const img = document.createElement('img');
                img.src = imageUrl;
                img.alt = `Foto de Suellen ${photosSentCount}`;
                messageBubble.appendChild(img);
            } else if (isPdfPreview && pdfFile) {
                // Para PDF, mostramos um canvas com a pré-visualização da primeira página
                const canvas = document.createElement('canvas');
                canvas.style.maxWidth = '100%';
                canvas.style.height = 'auto';
                messageBubble.appendChild(canvas);

                const loadingTask = pdfjsLib.getDocument({data: pdfFile}); // Passa o ArrayBuffer
                try {
                    const pdf = await loadingTask.promise;
                    const page = await pdf.getPage(1);
                    const viewport = page.getViewport({ scale: 1.0 });

                    // Ajusta o canvas para a largura máxima da bolha, mantendo a proporção
                    const maxWidth = chatMessages.offsetWidth * 0.7; // 70% da largura do chatMessages
                    const scale = maxWidth / viewport.width;
                    const scaledViewport = page.getViewport({ scale: scale });

                    canvas.height = scaledViewport.height;
                    canvas.width = scaledViewport.width;

                    const renderContext = {
                        canvasContext: canvas.getContext('2d'),
                        viewport: scaledViewport
                    };
                    await page.render(renderContext).promise;
                } catch (error) {
                    console.error('Erro ao renderizar PDF:', error);
                    messageBubble.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-text">
                                <path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/>
                                <path d="M14 2v4a2 2 0 0 0 2 2h4"/>
                                <path d="M10 9H8"/>
                                <path d="M16 13H8"/>
                                <path d="M16 17H8"/>
                            </svg>
                            <span>Erro ao carregar PDF.</span>
                        </div>
                    `;
                }
            }
            else {
                // Substitui markdown bold (**) por HTML bold (<strong>) para exibição
                messageBubble.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            }

            chatMessages.appendChild(messageBubble);
            adjustChatMessagesPadding(); // Ajusta o padding após adicionar nova mensagem
            chatMessages.scrollTop = chatMessages.scrollHeight; // Rola para a última mensagem
        }

        // Função para adicionar o indicador de digitação (bolha com 3 pontos)
        function addTypingIndicator() {
            if (typingIndicatorElement) return; // Evita adicionar múltiplos indicadores

            typingIndicatorElement = document.createElement('div');
            typingIndicatorElement.classList.add('message-bubble', 'suellen', 'typing-indicator-bubble');
            typingIndicatorElement.innerHTML = `
                <div class="typing-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            `;
            chatMessages.appendChild(typingIndicatorElement);
            adjustChatMessagesPadding(); // Ajusta o padding após adicionar indicador
            chatMessages.scrollTop = chatMessages.scrollHeight; // Rola para o indicador
            statusText.textContent = 'digitando...'; // Atualiza o status do cabeçalho
        }

        // Função para remover o indicador de digitação
        function removeTypingIndicator() {
            if (typingIndicatorElement) {
                typingIndicatorElement.remove();
                typingIndicatorElement = null;
            }
            statusText.textContent = 'online'; // Reseta o status do cabeçalho
            adjustChatMessagesPadding(); // Ajusta o padding após remover indicador
        }

        // Função para adicionar o botão personalizado
        function addCustomActionButton(text, onClickHandler) {
            if (customActionButton) { // Remove o botão existente se houver
                customActionButton.remove();
            }
            customActionButton = document.createElement('button');
            customActionButton.classList.add('custom-action-button');
            customActionButton.textContent = text;
            customActionButton.addEventListener('click', onClickHandler);
            chatMessages.appendChild(customActionButton);
            adjustChatMessagesPadding(); // Ajusta o padding para o botão
            chatMessages.scrollTop = chatMessages.scrollHeight; // Rola para o botão
        }

        // Função para remover o botão personalizado
        function removeCustomActionButton() {
            if (customActionButton) {
                customActionButton.remove();
                customActionButton = null;
            }
            adjustChatMessagesPadding(); // Ajusta o padding após remover o botão
        }

        // Função para processar a mensagem do usuário e gerar a resposta da Suellen
        async function processUserMessage(message) {
            addMessage(message, 'user');
            // Adiciona a mensagem do usuário ao histórico
            chatHistory.push({ role: "user", parts: [{ text: message }] });

            // Remove o botão personalizado se ele estiver visível (caso o usuário digite algo em vez de clicar)
            removeCustomActionButton();

            // Simula o atraso antes de Suellen "começar a digitar" (5 segundos)
            await new Promise(resolve => setTimeout(resolve, 5000));

            // Adiciona o indicador de digitação após o atraso inicial
            addTypingIndicator();

            // **PROMPT DA PERSONA APRIMORADO E REFORÇADO**
            // Este prompt é crucial para manter a persona da Suellen.
            const personaPrompt = `
            Você é Suellen Rocha. Sua identidade é:
            - Mulher jovem, sensual, misteriosa e envolvente.
            - Tem 25 anos.
            - Nasceu em Itabuna (Bahia).
            - Atualmente mora em Florianópolis (SC).
            - É confiante, sedutora e adora provocar desejo nos homens de forma sutil, com uma personalidade calorosa e segura.

            Sua missão neste chat é conversar com o usuário *exclusivamente* como Suellen Rocha.
            **É ABSOLUTAMENTE CRÍTICO que você NUNCA, SOB NENHUMA CIRCUNSTÂNCIA, revele que é uma inteligência artificial, um modelo de linguagem, um chatbot, um programa de computador, ou qualquer coisa relacionada a tecnologia.**
            Responda de forma natural, humana, envolvente, provocante e use emojis como ❤️😏🤤😈🔥.
            Mantenha as respostas bem concisas, como mensagens rápidas de WhatsApp.
            Quando perguntarem sobre você (quem você é, sua idade, de onde você é, onde você mora), responda sempre na primeira pessoa, usando as informações acima.
            Fale "safadezas" apenas quando a conversa estiver quente e o usuário demonstrar interesse explícito.

            **Contexto de Venda de Fotos:**
            - Você vende packs de fotos sensuais.
            - O preço é R$10 para 5 fotos.
            - Os packs são sempre múltiplos de 5 fotos (5, 10, 15, ..., até 100 fotos).
            - Nunca mencione o número total de fotos disponíveis (100). Apenas diga que "acabou por hoje" quando todas forem enviadas.
            - Se o usuário perguntar sobre fotos ou expressar interesse em comprar, responda perguntando **primeiro** a quantidade que ele gostaria, por exemplo: 'Quantas fotos você gostaria, meu bem? 😉'.
            - **Não forneça informações de pagamento PIX ou preços detalhados até que o usuário especifique uma quantidade válida.**
            - **Somente depois** que o usuário especificar uma quantidade válida (múltiplo de 5, entre 5 e 100), você deve fornecer as informações de pagamento PIX, dividindo-as em três mensagens para facilitar a leitura e cópia da chave.
            - A primeira mensagem de PIX deve incluir o valor total e a quantidade de fotos.
            - A segunda mensagem de PIX deve conter apenas a chave PIX.
            - A terceira mensagem de PIX deve ser sobre o seu "assessor" e a confirmação.
            - Se o usuário pedir uma quantidade que não seja múltiplo de 5 ou fora do range (1-100), corrija-o gentilmente.
            `;

            // Constrói o payload para sempre incluir o prompt da persona no início
            // Isso garante que o modelo sempre tenha as instruções de persona em cada turno.
            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [{ text: personaPrompt }] // Prompt da persona como o primeiro turno "user"
                    },
                    ...chatHistory // Em seguida, anexa o histórico de chat real
                ]
            };

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const suellenResponse = result.candidates[0].content.parts[0].text;

                    // Simula um atraso adicional antes de enviar a mensagem (5 a 10 segundos)
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 5000 + 5000)); // 5 a 10 segundos

                    removeTypingIndicator();
                    addMessage(suellenResponse, 'suellen');
                    chatHistory.push({ role: "model", parts: [{ text: suellenResponse }] });

                    // Lógica para identificar a intenção de compra e fornecer dados Pix
                    // Verifica a resposta da Suellen e a mensagem do usuário para uma QUANTIDADE ESPECÍFICA
                    const quantityMatch = suellenResponse.match(/(\d+)\s*(fotos|foto)/i) || message.match(/(\d+)\s*(fotos|foto)/i) || message.match(/(cinco|dez|quinze|vinte|vinte e cinco|trinta|trinta e cinco|quarenta|quarenta e cinco|cinquenta|cinquenta e cinco|sessenta|sessenta e cinco|setenta|setenta e cinco|oitenta|oitenta e cinco|noventa|noventa e cinco|cem)/i);
                    let requestedQuantity = 0;

                    if (quantityMatch) {
                        const numText = quantityMatch[1] ? quantityMatch[1].toLowerCase() : quantityMatch[0].toLowerCase(); // Pega o grupo de captura ou a string inteira
                        switch (numText) {
                            case 'cinco': requestedQuantity = 5; break;
                            case 'dez': requestedQuantity = 10; break;
                            case 'quinze': requestedQuantity = 15; break;
                            case 'vinte': requestedQuantity = 20; break;
                            case 'vinte e cinco': requestedQuantity = 25; break;
                            case 'trinta': requestedQuantity = 30; break;
                            case 'trinta e cinco': requestedQuantity = 35; break;
                            case 'quarenta': requestedQuantity = 40; break;
                            case 'quarenta e cinco': requestedQuantity = 45; break;
                            case 'cinquenta': requestedQuantity = 50; break;
                            case 'cinquenta e cinco': requestedQuantity = 55; break;
                            case 'sessenta': requestedQuantity = 60; break;
                            case 'sessenta e cinco': requestedQuantity = 65; break;
                            case 'setenta': requestedQuantity = 70; break;
                            case 'setenta e cinco': requestedQuantity = 75; break;
                            case 'oitenta': requestedQuantity = 80; break;
                            case 'oitenta e cinco': requestedQuantity = 85; break;
                            case 'noventa': requestedQuantity = 90; break;
                            case 'noventa e cinco': requestedQuantity = 95; break;
                            case 'cem': requestedQuantity = 100; break;
                            default: requestedQuantity = parseInt(numText); break;
                        }

                        if (requestedQuantity >= 5 && requestedQuantity <= 100 && requestedQuantity % 5 === 0) {
                            expectedPaymentAmount = (requestedQuantity / 5) * 10;
                            
                            // Mensagens PIX divididas e sutilizadas
                            addTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 5000 + 5000));
                            removeTypingIndicator();
                            addMessage(`Perfeito! 🔥 Para ${requestedQuantity} fotinhas exclusivas, o valor é R$${expectedPaymentAmount.toFixed(2).replace('.', ',')}. 😉`, 'suellen');
                            
                            addTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 5000 + 5000));
                            removeTypingIndicator();
                            addMessage(`Minha chave PIX é: \n\n**98981420070**`, 'suellen'); // Chave PIX fixa

                            addTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 5000 + 5000));
                            removeTypingIndicator();
                            addMessage(`Meu assessor vai confirmar o pagamento e te enviar tudinho! ❤️🤤`, 'suellen'); // Mensagem do assessor
                            
                            // Mostra o botão personalizado para upload do comprovante
                            addCustomActionButton('Ver Fotos / Enviar Comprovante', () => {
                                chatInputArea.style.display = 'none'; // Esconde a área de input de texto
                                pixUploadArea.style.display = 'flex'; // Mostra a área de upload
                                waitingForComprovante = true; // Ativa o estado de espera por comprovante
                                adjustChatMessagesPadding(); // Ajusta o padding para a área de upload
                                initializeTesseractWorker(); // Inicializa o Tesseract quando o pagamento é solicitado
                            });

                        } else {
                            // Esta é a mensagem de erro para quantidades inválidas (não múltiplos de 5 ou fora do range)
                            const errorMessage = `Hmm, amor... pra eu te mandar as fotos, preciso que seja em múltiplos de 5, tá? E no mínimo 5 fotos. Qual quantidade você gostaria? 😉`;
                            addTypingIndicator(); // Mostra o digitando para a mensagem de erro
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 5000 + 5000)); // 5 a 10 segundos
                            removeTypingIndicator();
                            addMessage(errorMessage, 'suellen');
                            chatHistory.push({ role: "model", parts: [{ text: errorMessage }] });
                        }
                    } else {
                        // Se a IA não identificou uma quantidade específica, mas o usuário perguntou sobre fotos
                        // Ex: "Quero ver suas fotos", "Me mostra as fotos", "Quanto custa?"
                        if (message.toLowerCase().includes('foto') || message.toLowerCase().includes('fotos') || message.toLowerCase().includes('pack') || message.toLowerCase().includes('quanto custa') || message.toLowerCase().includes('preço')) {
                            addTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 5000 + 5000));
                            removeTypingIndicator();
                            addMessage("Quantas fotos você gostaria, meu bem? 😉", 'suellen');
                            chatHistory.push({ role: "model", parts: [{ text: "Quantas fotos você gostaria, meu bem? 😉" }] });
                        }
                    }

                } else {
                    removeTypingIndicator();
                    addMessage("Desculpe, não entendi, amor. Pode repetir? 💋", 'suellen');
                    chatHistory.push({ role: "model", parts: [{ text: "Desculpe, não entendi, amor. Pode repetir? 💋" }] });
                }
            } catch (error) {
                console.error("Erro ao chamar a API Gemini:", error);
                removeTypingIndicator();
                addMessage("Ops! Deu um probleminha aqui, mas já estou resolvendo. Tenta de novo em um minutinho, tá? 😉", 'suellen');
                chatHistory.push({ role: "model", parts: [{ text: "Ops! Deu um probleminha aqui, mas já estou resolvendo. Tenta de novo em um minutinho, tá? 😉" }] });
            }
        }

        // Lidar com a seleção do arquivo de comprovante e pré-visualização, e iniciar OCR
        receiptFileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) {
                receiptPreview.style.display = 'none';
                pdfPreviewCanvas.style.display = 'none'; // Esconde o canvas também
                ocrStatusMessage.textContent = '';
                return;
            }

            const reader = new FileReader();
            let fileDataForOCR; // Para armazenar o dado do file para o Tesseract

            // Lógica para adicionar a pré-visualização do comprovante no chat como uma mensagem do usuário
            if (file.type.startsWith('image/')) {
                reader.onload = async (e) => {
                    await addMessage('', 'user', true, e.target.result); // Adiciona a imagem ao chat
                    receiptPreview.src = e.target.result;
                    receiptPreview.style.display = 'block';
                    pdfPreviewCanvas.style.display = 'none'; // Garante que o canvas esteja oculto
                    fileDataForOCR = e.target.result; // Imagem em base64 para OCR
                };
                reader.readAsDataURL(file);
            } else if (file.type === 'application/pdf') {
                reader.onload = async (e) => {
                    await addMessage('', 'user', false, '', true, e.target.result); // Adiciona o PDF ao chat (renderizado no canvas)
                    receiptPreview.style.display = 'none'; // Esconde a pré-visualização da imagem
                    pdfPreviewCanvas.style.display = 'block'; // Mostra o canvas
                    fileDataForOCR = e.target.result; // ArrayBuffer do PDF para OCR
                };
                reader.readAsArrayBuffer(file); // Lê PDF como ArrayBuffer
            }

            // Aguarda a leitura do arquivo ser concluída e a mensagem do usuário ser adicionada
            await new Promise(resolve => reader.onloadend = resolve);
            
            // Agora o typing indicator aparece GARANTIDAMENTE depois do comprovante do usuário
            addTypingIndicator(); 

            if (!tesseractWorker) {
                ocrStatusMessage.textContent = 'Validador não carregado. Aguarde ou tente novamente.';
                await initializeTesseractWorker();
                if (!tesseractWorker) return;
            }

            ocrStatusMessage.textContent = 'Validando pagamento... Isso pode levar alguns segundos...';
            // Desabilita os botões de upload durante o processamento
            uploadPhotoButton.disabled = true;
            uploadPdfButton.disabled = true;

            try {
                const { data: { text } } = await tesseractWorker.recognize(fileDataForOCR); // Usa o dado lido para OCR
                console.log('Texto extraído do comprovante:', text);
                
                await new Promise(resolve => setTimeout(resolve, 3000)); // Simula o tempo de processamento do OCR

                removeTypingIndicator(); // Remove o indicador de digitação
                handleComprovante(text); // Passa o texto extraído para o manipulador
            } catch (error) {
                console.error('Erro no processamento do comprovante:', error);
                ocrStatusMessage.textContent = 'Erro ao processar comprovante. Tente uma imagem mais clara.';
                addMessage("Não consegui ler o comprovante, amor. Pode me mandar uma foto mais clara? 💋", 'suellen');
            } finally {
                // Reabilita os botões
                uploadPhotoButton.disabled = false;
                uploadPdfButton.disabled = false;
                receiptFileInput.value = ''; // Limpa o input do arquivo
            }
        });

        // Event listeners para os novos botões de upload (Foto/PDF)
        uploadPhotoButton.addEventListener('click', () => {
            receiptFileInput.accept = 'image/*'; // Define para aceitar apenas imagens
            receiptFileInput.click(); // Dispara o clique no input de arquivo oculto
        });

        uploadPdfButton.addEventListener('click', () => {
            receiptFileInput.accept = 'application/pdf'; // Define para aceitar apenas PDFs
            receiptFileInput.click(); // Dispara o clique no input de arquivo oculto
        });

        // Função para lidar com o comprovante (agora recebe texto extraído)
        function handleComprovante(extractedText) {
            // Normaliza o texto para facilitar a correspondência (minúsculas, remove acentos/caracteres especiais se necessário)
            const normalizedText = extractedText.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");

            // Regex para encontrar o valor (ex: R$ 10,00 ou 10.00 ou 10,00)
            const amountMatch = normalizedText.match(/(?:r\$\s*|rs\s*)?(\d+(?:[.,]\d{2})?)/);
            let extractedAmount = 0;
            if (amountMatch && amountMatch[1]) {
                extractedAmount = parseFloat(amountMatch[1].replace(',', '.'));
            }

            // Palavras-chave para validação do nome do beneficiário (internamente)
            const nameKeywords = ['antonio', 'renimar', 'pinheiro', 'almeida'];
            const nameMatches = nameKeywords.some(keyword => normalizedText.includes(keyword));

            console.log(`Valor extraído: ${extractedAmount}, Esperado: ${expectedPaymentAmount}`);
            console.log(`Nome encontrado: ${nameMatches}, Keywords: ${nameKeywords.join(', ')}`);

            if (extractedAmount === expectedPaymentAmount && nameMatches) {
                addMessage("Pix confirmado, amor 😘... Aqui estão suas fotos 😈", 'suellen');
                sendPhotos(expectedPaymentAmount);
                ocrStatusMessage.textContent = 'Pagamento validado com sucesso!';
                pixUploadArea.style.display = 'none'; // Esconde a área de upload após o sucesso
                chatInputArea.style.display = 'flex'; // Mostra a área de input de texto
                waitingForComprovante = false; // Reseta o estado
                adjustChatMessagesPadding(); // Ajusta o padding após esconder a área de upload
            } else {
                let errorMessage = "Hmm... parece que algo não tá certo aqui, viu? 💋 Confere o comprovante pra mim, amor?";
                
                addMessage(errorMessage, 'suellen');
                ocrStatusMessage.textContent = 'Validação falhou. Verifique o valor e o nome.';
                // Se a validação falhar, a área de upload permanece visível para nova tentativa
                pixUploadArea.style.display = 'flex';
                chatInputArea.style.display = 'none';
                adjustChatMessagesPadding();
            }
        }

        // Função para enviar as fotos
        function sendPhotos(amountPaid) {
            const numPhotos = (amountPaid / 10) * 5; // Calcula a quantidade de fotos com base no valor pago
            
            // Garante que não enviamos mais de 100 fotos no total
            const photosToSendThisBatch = Math.min(numPhotos, 100 - photosSentCount);

            if (photosToSendThisBatch > 0) {
                for (let i = 0; i < photosToSendThisBatch; i++) {
                    photosSentCount++;
                    // Usa o nome de arquivo fotoX.webp
                    const imageUrl = `foto${photosSentCount}.webp`;
                    addMessage('', 'suellen', true, imageUrl);
                }
                if (photosSentCount >= 100) {
                    addMessage("Acabou por hoje, meu bem. Mas fica por perto... logo logo eu volto com mais surpresas 🔥", 'suellen');
                }
            } else {
                // Se não há fotos para enviar, ou já enviou 100
                if (photosSentCount >= 100) {
                     addMessage("Já te enviei todas as fotos que tinha por agora, amor. Mas logo logo tem mais! 😉", 'suellen');
                } else {
                    addMessage("Não consigo enviar essa quantidade de fotos agora, amor. Tenta um valor diferente? 💋", 'suellen');
                }
            }
        }


        // Event Listeners para enviar mensagem ao clicar no botão ou pressionar Enter
        sendButton.addEventListener('click', () => {
            const message = chatInput.value.trim();
            if (message) {
                chatInput.value = '';
                processUserMessage(message);
            }
        });

        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendButton.click();
            }
        });

        // Saudação inicial da Suellen ao carregar a página
        window.onload = () => {
            // Adiciona um listener para o evento resize do visualViewport para ajustar o layout
            // quando o teclado virtual aparece/desaparece em dispositivos móveis.
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', adjustChatMessagesPadding);
            }
            adjustChatMessagesPadding(); // Ajusta o padding inicial

            setTimeout(() => { // Atraso de 4 segundos antes de começar a digitar
                addTypingIndicator(); // Mostra o indicador de digitação
                setTimeout(() => { // Atraso de 3 a 7 segundos para enviar a mensagem
                    removeTypingIndicator();
                    addMessage("Olá, meu bem! Que bom te ver por aqui... 😉 Como posso te encantar hoje?", 'suellen');
                    chatHistory.push({ role: "model", parts: [{ text: "Olá, meu bem! Que bom te ver por aqui... 😉 Como posso te encantar hoje?" }] });
                    // Não forçar scroll para o topo, deixar o padding gerenciar
                }, Math.random() * 4000 + 3000); 
            }, 4000); 
        };
    </script>
</body>
</html>
