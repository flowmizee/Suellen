<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat de Vendas</title>
    <style>
        :root {
            --primary-color: #25D366;
            --secondary-color: #128C7E;
            --dark-color: #075E54;
            --light-color: #DCF8C6;
            --white: #FFFFFF;
            --gray: #ECE5DD;
            --dark-gray: #667781;
            --error-color: #FF3B30;
            --success-color: #34C759;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Helvetica, Arial, sans-serif;
        }

        body {
            background-color: var(--gray);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden; /* Prevent body scroll */
        }

        .chat-container {
            width: 100%;
            max-width: 450px;
            height: 100vh;
            background-color: var(--white);
            display: flex;
            flex-direction: column;
            box-shadow: 0 1px 10px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        .chat-header {
            background-color: var(--dark-color);
            color: var(--white);
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        .profile-pic {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        .header-info h2 {
            font-size: 16px;
            font-weight: 600;
        }

        .header-info p {
            font-size: 12px;
            opacity: 0.8;
        }

        .chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background-color: var(--gray);
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABmJLR0QA/wD/AP+gvaeTAAAA+UlEQVQ4y+3UMUoDQRTG8Z8psJBUKTyAR7ATvIBgYSM2Fh7AG3gBG0GxECwELQJik1qwsBAkEIuQZLGwsJj3LDOw7CabTbzwYJh5M9/7Zpg3Q6VSqfQf1cMq9vGCN7zjCQ+4xW2RcIh7fOITL3jGMx7xiDvc4BqX2M0TDnCHL3zjK1Nf+MAn3nGNCQZZwj4u8I5xgegYI1xiJ0vYxQhvBcI8jXGOrSzhBq4KRP9qiPUs4RouCkT/6gJrWcIlnBeI/tUZFrOECzjLEf2rU8xnCedxkiP6V8eYyxLO4ShH9K8OMZMlnMZ+jmhSe5jKEk5hL0c0qV1MZgkT7OSIJrWNiSxhnG1sZYkmtYmxLGGMTWxkiSa1jv+JfgCJ5DfAoYx1jAAAAABJRU5ErkJggg==');
            display: flex;
            flex-direction: column;
            gap: 8px;
            /* Allow messages to be larger */
            font-size: 15px; 
        }

        .message {
            max-width: 80%;
            padding: 10px 14px; /* Slightly larger padding */
            border-radius: 8px;
            font-size: 15px; /* Larger font size */
            line-height: 1.4;
            word-wrap: break-word;
            position: relative;
        }

        .message.user {
            background-color: var(--light-color);
            align-self: flex-end;
            border-bottom-right-radius: 0;
        }

        .message.bot {
            background-color: var(--white);
            align-self: flex-start;
            border-bottom-left-radius: 0;
        }

        .message img {
            max-width: 100%;
            border-radius: 5px;
            margin-top: 5px;
        }

        .typing-indicator {
            background-color: var(--white);
            padding: 8px 12px;
            border-radius: 8px;
            align-self: flex-start;
            display: inline-flex;
            gap: 4px;
        }

        .typing-indicator span {
            width: 6px;
            height: 6px;
            background-color: var(--dark-gray);
            border-radius: 50%;
            display: inline-block;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .typing-indicator span:nth-child(1) { animation-delay: 0s; }
        .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        .pix-upload-area {
            display: none; /* Controlled by JS */
            padding: 15px;
            background-color: var(--white);
            border-top: 1px solid #ddd;
            flex-direction: column;
            gap: 10px;
            flex-shrink: 0; /* Prevent from shrinking */
        }

        .preview-container {
            max-height: 200px;
            overflow: hidden;
            border-radius: 8px;
            background-color: #f5f5f5;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .preview-container img {
            max-width: 100%;
            max-height: 200px;
            object-fit: contain;
        }

        .preview-container canvas {
            max-width: 100%;
            max-height: 200px;
            border-radius: 8px;
        }

        .upload-buttons {
            display: flex;
            gap: 10px;
        }

        .upload-button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            background-color: var(--primary-color);
            color: var(--white);
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .upload-button:hover {
            background-color: var(--secondary-color);
        }

        .status-message {
            font-size: 12px;
            text-align: center;
            color: var(--dark-gray);
        }

        .error-message {
            color: var(--error-color);
            font-weight: 500;
        }

        .success-message {
            color: var(--success-color);
            font-weight: 500;
        }

        .pix-info {
            background-color: #f0f0f0;
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 13px;
        }

        .pix-info p {
            margin: 5px 0;
        }

        .action-button {
            background-color: var(--dark-color);
            color: var(--white);
            border: none;
            border-radius: 20px;
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            margin-top: 10px;
            align-self: center;
        }

        .action-button:hover {
            background-color: #054d43;
        }

        #file-input {
            display: none;
        }

        .chat-input-area {
            padding: 10px;
            background-color: var(--white);
            border-top: 1px solid #ddd;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0; /* Prevent input area from shrinking */
        }

        .chat-input {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 20px;
            background-color: var(--gray);
            font-size: 14px;
            outline: none;
        }

        .send-button {
            width: 40px;
            height: 40px;
            background-color: var(--primary-color);
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .send-button:hover {
            background-color: var(--secondary-color);
        }

        .attachment-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
        }

        .option-buttons {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .option-button {
            background-color: var(--dark-color);
            color: var(--white);
            border: none;
            border-radius: 20px;
            padding: 8px 12px;
            font-size: 13px;
            cursor: pointer;
        }

        .option-button:hover {
            background-color: #054d43;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <img src="perfil.webp" alt="Perfil" class="profile-pic" onerror="this.src='https://via.placeholder.com/40'">
            <div class="header-info">
                <h2>Suellen Rocha</h2>
                <p id="status-text">online</p>
            </div>
        </div>

        <div class="chat-messages" id="chat-messages">
            </div>

        <div class="pix-upload-area" id="pix-upload-area">
            <div class="preview-container">
                <img id="receipt-preview" style="display: none;">
                <canvas id="pdf-preview" style="display: none;"></canvas>
            </div>
            <p id="ocr-status" class="status-message">Envie seu comprovante</p>
            <div class="upload-buttons">
                <button class="upload-button" id="upload-photo">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3z"></path>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                        <line x1="12" y1="19" x2="12" y2="23"></line>
                        <line x1="8" y1="23" x2="16" y2="23"></line>
                    </svg>
                    Enviar Foto
                </button>
                <button class="upload-button" id="upload-pdf">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <polyline points="14 2 14 8 20 8"></polyline>
                        <line x1="16" y1="13" x2="8" y2="13"></line>
                        <line x1="16" y1="17" x2="8" y2="17"></line>
                        <polyline points="10 9 9 9 8 9"></polyline>
                    </svg>
                    Enviar PDF
                </button>
            </div>
            <input type="file" id="file-input" accept="image/*,.pdf">
        </div>

        <div class="chat-input-area">
            <button class="attachment-button" id="attach-button">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                </svg>
            </button>
            <input type="text" class="chat-input" id="chat-input" placeholder="Digite sua mensagem...">
            <button class="send-button" id="send-button">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="22" y1="2" x2="11" y2="13"></line>
                    <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                </svg>
            </button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js"></script>
    <script>
        // Configuração do PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';

        // Elementos do DOM
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');
        const attachButton = document.getElementById('attach-button');
        const uploadPhotoButton = document.getElementById('upload-photo');
        const uploadPdfButton = document.getElementById('upload-pdf');
        const fileInput = document.getElementById('file-input');
        const pixUploadArea = document.getElementById('pix-upload-area');
        const receiptPreview = document.getElementById('receipt-preview');
        const pdfPreview = document.getElementById('pdf-preview');
        const ocrStatus = document.getElementById('ocr-status');
        const statusText = document.getElementById('status-text');

        // Variáveis de estado
        let chatHistory = [];
        let photosSentCount = 0;
        let expectedPaymentAmount = 0;
        let isWaitingPayment = false;
        let typingIndicator = null;
        let tesseractWorker = null;

        // Valores válidos para PIX e suas fotos correspondentes
        const validPaymentAmounts = {
            10: 5,
            20: 10,
            30: 15,
            40: 20,
            50: 25,
            60: 30,
            70: 35,
            80: 40,
            90: 45,
            100: 50,
            110: 55,
            120: 60,
            130: 65,
            140: 70,
            150: 75,
            160: 80,
            170: 85,
            180: 90,
            190: 95,
            200: 100
        };

        // Nomes válidos para PIX (convertidos para minúsculas e sem acentos para comparação)
        const validNames = ['antonio', 'renimar', 'pinheiro', 'almeida'];

        // Fotos já enviadas para evitar repetição
        let sentPhotoIndices = new Set();

        // Inicialização
        window.onload = async () => {
            // Saudação inicial
            setTimeout(async () => {
                await addMessageWithDelay("Olá, meu bem! Que bom te ver por aqui... 😉", 'bot');
                await addMessageWithDelay("Eu sou a Suellen Rocha e estou aqui para te oferecer fotos exclusivas!", 'bot');
                await addMessageWithDelay("Quantas fotos você gostaria de receber? (5, 10, 15, ..., até 100)", 'bot');
            }, 1000);

            // Event listeners
            sendButton.addEventListener('click', sendUserMessage);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendUserMessage();
            });

            attachButton.addEventListener('click', () => {
                // Ensure the file input is ready for image or PDF
                fileInput.accept = 'image/*,.pdf';
                fileInput.click();
            });

            uploadPhotoButton.addEventListener('click', () => {
                fileInput.accept = 'image/*'; // Specifically for photos
                fileInput.click();
            });

            uploadPdfButton.addEventListener('click', () => {
                fileInput.accept = '.pdf'; // Specifically for PDFs
                fileInput.click();
            });

            fileInput.addEventListener('change', handleFileUpload);
        };

        // Função para enviar mensagem do usuário
        function sendUserMessage() {
            const message = chatInput.value.trim();
            if (!message) return;

            addMessage(message, 'user');
            chatInput.value = '';
            
            // Processar a mensagem do usuário
            processUserMessage(message);
        }

        // Função para processar a mensagem do usuário
        async function processUserMessage(message) {
            // Verificar se é uma solicitação de quantidade de fotos
            const quantityMatch = message.match(/(\d+)/);
            if (quantityMatch) {
                const requestedQuantity = parseInt(quantityMatch[1]);
                
                // Check if the requested quantity is valid based on validPaymentAmounts keys
                const foundAmount = Object.keys(validPaymentAmounts).find(amount => validPaymentAmounts[amount] === requestedQuantity);

                if (foundAmount) {
                    expectedPaymentAmount = parseFloat(foundAmount);
                    
                    await addMessageWithDelay(`Perfeito! Para ${requestedQuantity} fotos exclusivas, o valor é R$${expectedPaymentAmount.toFixed(2)}. 😉`, 'bot');
                    await addMessageWithDelay(`Minha chave PIX é: \n\n**98981420070** (CPF)\n\nNome: **Antonio Renimar Pinheiro Almeida**`, 'bot');
                    await addMessageWithDelay(`Envie o comprovante aqui mesmo que eu libero suas fotos! ❤️`, 'bot');
                    
                    // Mostrar área de upload
                    showPixUploadArea();
                    return;
                }
            }
            
            // If not a valid quantity or other message
            if (!isWaitingPayment) { // Only suggest quantity if not waiting for payment
                await addMessageWithDelay("Por favor, me diga quantas fotos você gostaria (5, 10, 15, etc.)", 'bot');
            } else {
                await addMessageWithDelay("Ainda estou esperando seu comprovante PIX! Por favor, envie-o para que eu possa liberar suas fotos.", 'bot');
            }
        }

        // Função para mostrar a área de upload do PIX
        function showPixUploadArea() {
            isWaitingPayment = true;
            pixUploadArea.style.display = 'flex';
            scrollToBottom();
        }

        // Função para lidar com upload de arquivo
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Resetar previews and status
            receiptPreview.style.display = 'none';
            pdfPreview.style.display = 'none';
            ocrStatus.textContent = 'Envie seu comprovante';
            ocrStatus.className = 'status-message'; // Reset classes

            if (file.type.startsWith('image/')) {
                // Processar imagem
                const reader = new FileReader();
                reader.onload = async (e) => {
                    receiptPreview.src = e.target.result;
                    receiptPreview.style.display = 'block';
                    
                    // Adicionar mensagem com a imagem
                    addMessage('', 'user', true, e.target.result);
                    
                    // Processar OCR
                    await processReceipt(e.target.result, 'image');
                };
                reader.readAsDataURL(file);
            } else if (file.type === 'application/pdf') {
                // Processar PDF
                const arrayBuffer = await file.arrayBuffer();
                
                // Mostrar preview do PDF
                try {
                    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                    const page = await pdf.getPage(1);
                    const viewport = page.getViewport({ scale: 1.5 });
                    
                    pdfPreview.height = viewport.height;
                    pdfPreview.width = viewport.width;
                    
                    const renderContext = {
                        canvasContext: pdfPreview.getContext('2d'),
                        viewport: viewport
                    };
                    
                    await page.render(renderContext).promise;
                    pdfPreview.style.display = 'block';
                    
                    // Add a placeholder message for the PDF, as the actual content is in the preview
                    addMessage('Comprovante em PDF enviado', 'user');

                    // Processar OCR do PDF
                    await processReceipt(arrayBuffer, 'pdf');

                } catch (pdfError) {
                    console.error('Erro ao renderizar PDF:', pdfError);
                    ocrStatus.textContent = 'Erro ao carregar PDF. Tente novamente.';
                    ocrStatus.className = 'status-message error-message';
                    await addMessageWithDelay("Não consegui carregar o PDF. Por favor, certifique-se de que é um arquivo PDF válido e tente novamente.", 'bot');
                    showPixUploadArea();
                }
            } else {
                ocrStatus.textContent = 'Formato de arquivo não suportado. Envie imagem ou PDF.';
                ocrStatus.className = 'status-message error-message';
                await addMessageWithDelay("Por favor, envie seu comprovante como imagem (JPG, PNG) ou PDF.", 'bot');
                showPixUploadArea();
            }
        }

        // Função para processar o comprovante (OCR)
        async function processReceipt(fileData, type) {
            ocrStatus.textContent = 'Processando comprovante...';
            ocrStatus.className = 'status-message';
            
            try {
                // Inicializar o Tesseract se necessário
                if (!tesseractWorker) {
                    tesseractWorker = await Tesseract.createWorker('por');
                }
                
                let text = '';
                
                if (type === 'image') {
                    // Processar imagem diretamente
                    const { data: { text: extractedText } } = await tesseractWorker.recognize(fileData);
                    text = extractedText;
                } else if (type === 'pdf') {
                    // Processar PDF página por página (OCR image-based for Tesseract)
                    // Tesseract.js cannot directly OCR PDFs, so we render the PDF to an image (canvas) first.
                    // However, if the PDF already contains selectable text, we can extract that first.
                    // For robust OCR, we'll convert PDF pages to images and then OCR.

                    const pdf = await pdfjsLib.getDocument(fileData).promise;
                    let fullPdfText = [];
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const viewport = page.getViewport({ scale: 2 }); // Higher scale for better OCR
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;

                        await page.render({ canvasContext: context, viewport: viewport }).promise;
                        
                        const imageData = canvas.toDataURL('image/png');
                        const { data: { text: extractedPageText } } = await tesseractWorker.recognize(imageData);
                        fullPdfText.push(extractedPageText);
                    }
                    text = fullPdfText.join('\n');
                }
                
                // Validate the receipt
                await validateReceipt(text);
                
            } catch (error) {
                console.error('Erro no OCR:', error);
                ocrStatus.textContent = 'Erro ao processar comprovante';
                ocrStatus.className = 'status-message error-message';
                
                await addMessageWithDelay("Ocorreu um erro ao processar seu comprovante. Por favor, tente novamente ou envie uma imagem mais clara.", 'bot');
                showPixUploadArea();
            }
        }

        // Função para validar o texto do comprovante
        async function validateReceipt(text) {
            ocrStatus.textContent = 'Validando pagamento...';
            
            // Normalizar o texto para comparação (lowercase, remove accents, remove non-alphanumeric except for .,)
            const normalizedText = text.toLowerCase()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .replace(/[^a-z0-9\s.,]/g, '');
            
            // Check if any of the valid names are present
            const hasValidName = validNames.some(name => normalizedText.includes(name));
            
            // Extract all monetary values from the text
            // Improved regex to capture common Brazilian currency formats (e.g., 1.234,56 or 1234,56 or 1234.56)
            const amountPattern = /(?:r\$\s*|rs\s*)?(\d{1,3}(?:\.\d{3})*(?:,\d{2})?|\d+(?:,\d{2})?)/g;
            let extractedAmounts = [];
            let match;
            
            while ((match = amountPattern.exec(normalizedText)) !== null) {
                // Convert to number (replace comma with dot for decimal, remove thousand separators)
                let amountStr = match[1].replace(/\./g, '').replace(',', '.');
                const amount = parseFloat(amountStr);
                // Only add valid numbers, filter out NaN or very small numbers (likely not currency)
                if (!isNaN(amount) && amount > 0.01) {
                    extractedAmounts.push(amount);
                }
            }
            
            // Find the closest value to the expected amount within a small tolerance
            let amountMatches = false;
            if (extractedAmounts.length > 0) {
                const tolerance = 0.5; // Allow for a small difference, e.g., R$0.50
                amountMatches = extractedAmounts.some(amount => 
                    Math.abs(amount - expectedPaymentAmount) <= tolerance
                );
            }
            
            // Simulate processing
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            if (hasValidName && amountMatches) {
                // Payment validated
                ocrStatus.textContent = 'Pagamento confirmado!';
                ocrStatus.className = 'status-message success-message';
                
                pixUploadArea.style.display = 'none';
                isWaitingPayment = false;
                
                await addMessageWithDelay("Pagamento confirmado! Aqui estão suas fotos exclusivas 😘", 'bot');
                
                // Send the photos
                await sendPhotos(expectedPaymentAmount);
                
            } else {
                // Payment not validated
                ocrStatus.textContent = 'Pagamento não reconhecido';
                ocrStatus.className = 'status-message error-message';
                
                let errorMessage = "Não consegui validar seu pagamento. Por favor, verifique:\n\n";
                errorMessage += `- O valor está correto? (R$${expectedPaymentAmount.toFixed(2).replace('.', ',')})\n`;
                errorMessage += "- O comprovante é para a chave PIX: 98981420070 (CPF)\n";
                errorMessage += "- O nome no comprovante é: Antonio Renimar Pinheiro Almeida\n\n";
                errorMessage += "Você pode tentar enviar novamente:";
                
                await addMessageWithDelay(errorMessage, 'bot');
                showPixUploadArea();
            }
        }

        // Função para enviar as fotos
        async function sendPhotos(amountPaid) {
            const numPhotosToDeliver = validPaymentAmounts[amountPaid];
            
            if (numPhotosToDeliver === undefined) {
                await addMessageWithDelay("Não consigo determinar a quantidade de fotos para este valor. Por favor, insira a quantidade de fotos que deseja (5, 10, etc.).", 'bot');
                return;
            }

            const totalAvailablePhotos = 100; // Assuming 100 unique photos exist
            let photosSentThisTransaction = 0;

            // Send photos one by one
            for (let i = 0; i < numPhotosToDeliver; i++) {
                if (photosSentCount >= totalAvailablePhotos) {
                    await addMessageWithDelay("Você já recebeu todas as fotos disponíveis! Obrigada por participar ❤️", 'bot');
                    break; 
                }

                let photoIndex = photosSentCount + 1; // Start from the next available photo
                
                // Ensure unique photos up to 100
                while (sentPhotoIndices.has(photoIndex) && photoIndex <= totalAvailablePhotos) {
                    photoIndex++;
                }

                if (photoIndex > totalAvailablePhotos) {
                    await addMessageWithDelay("Chegamos ao limite de fotos disponíveis. Obrigada por participar ❤️", 'bot');
                    break;
                }

                const photoUrl = `foto${photoIndex}.webp`; // Assuming foto1.webp, foto2.webp, etc.
                
                showTypingIndicator();
                await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate typing
                hideTypingIndicator();
                
                addMessage('', 'bot', true, photoUrl);
                sentPhotoIndices.add(photoIndex); // Mark as sent
                photosSentCount++;
                photosSentThisTransaction++;

                // Small delay between photos
                if (i < numPhotosToDeliver - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            if (photosSentCount >= totalAvailablePhotos) {
                await addMessageWithDelay("Essas foram todas as fotos disponíveis! Espero que tenha gostado 😘", 'bot');
            } else if (photosSentThisTransaction > 0) { // Only show this if photos were actually sent in this transaction
                await addMessageWithDelay(`Você já recebeu um total de ${photosSentCount} fotos. Quer mais?`, 'bot');
            }
        }

        // Funções auxiliares para mensagens
        function addMessage(text, sender, isImage = false, imageUrl = '') {
            const messageElement = document.createElement('div');
            messageElement.className = `message ${sender}`;
            
            if (isImage) {
                const img = document.createElement('img');
                img.src = imageUrl;
                img.alt = 'Foto enviada';
                // Add an onerror to handle broken image links gracefully
                img.onerror = function() { this.src = 'https://via.placeholder.com/150?text=Imagem+N%C3%A3o+Encontrada'; };
                messageElement.appendChild(img);
            } else {
                messageElement.innerHTML = text.replace(/\n/g, '<br>'); // Handle newlines
            }
            
            chatMessages.appendChild(messageElement);
            scrollToBottom();
        }

        async function addMessageWithDelay(text, sender, delayMs = 1000) {
            showTypingIndicator();
            await new Promise(resolve => setTimeout(resolve, delayMs));
            hideTypingIndicator();
            addMessage(text, sender);
        }

        function showTypingIndicator() {
            if (typingIndicator) return;
            
            typingIndicator = document.createElement('div');
            typingIndicator.className = 'typing-indicator';
            typingIndicator.innerHTML = '<span></span><span></span><span></span>';
            
            const messageElement = document.createElement('div');
            messageElement.className = 'message bot';
            messageElement.appendChild(typingIndicator);
            
            chatMessages.appendChild(messageElement);
            scrollToBottom();
            
            statusText.textContent = 'digitando...';
        }

        function hideTypingIndicator() {
            if (!typingIndicator) return;
            
            typingIndicator.parentElement.remove();
            typingIndicator = null;
            
            statusText.textContent = 'online';
        }

        function scrollToBottom() {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Adjust chat container height for mobile (visual viewport API)
        // This helps prevent the input area from being covered by the virtual keyboard.
        if (window.visualViewport) {
            function adjustHeight() {
                document.querySelector('.chat-container').style.height = window.visualViewport.height + 'px';
            }
            window.visualViewport.addEventListener('resize', adjustHeight);
            adjustHeight(); // Initial adjustment
        }
    </script>
</body>
</html>
